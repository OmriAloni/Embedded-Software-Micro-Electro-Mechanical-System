Sources\MPU9250.o:     file format elf32-littlearmSources\MPU9250.oarchitecture: arm, flags 0x00000011:HAS_RELOC, HAS_SYMSstart address 0x00000000private flags = 5000000: [Version5 EABI]Sections:Idx Name          Size      VMA       LMA       File off  Algn  0 .text         00000000  00000000  00000000  00000034  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE  1 .data         00000000  00000000  00000000  00000034  2**0                  CONTENTS, ALLOC, LOAD, DATA  2 .bss          00000000  00000000  00000000  00000034  2**0                  ALLOC  3 .text.getMres 00000034  00000000  00000000  00000034  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  4 .text.getGres 00000058  00000000  00000000  00000068  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  5 .text.getAres 00000050  00000000  00000000  000000c0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  6 .text.readAccelData 00000068  00000000  00000000  00000110  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  7 .text.readGyroData 00000068  00000000  00000000  00000178  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  8 .text.readMagData 00000094  00000000  00000000  000001e0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  9 .text.readTempData 0000002c  00000000  00000000  00000274  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.initAK8963 00000168  00000000  00000000  000002a0  2**3                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.initMPU9250 00000118  00000000  00000000  00000408  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 12 .text.MPU9250SelfTest 00000858  00000000  00000000  00000520  2**3                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 13 .rodata       00000010  00000000  00000000  00000d78  2**2                  CONTENTS, ALLOC, LOAD, READONLY, DATA 14 .text.magcalMPU9250 00000370  00000000  00000000  00000d88  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 15 .text.calibrateMPU9250 00000790  00000000  00000000  000010f8  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 16 .text.readData 0000027c  00000000  00000000  00001888  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 17 .text.accelWakeOnMotion 000000a0  00000000  00000000  00001b04  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 18 .text.gyromagSleep 0000005c  00000000  00000000  00001ba4  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 19 .text.gyromagWake 00000064  00000000  00000000  00001c00  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 20 .text.resetMPU9250 00000018  00000000  00000000  00001c64  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 21 .text.readMPU9250Data 000000d0  00000000  00000000  00001c7c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 22 .text.checkNewMagData 00000024  00000000  00000000  00001d4c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 23 .text.checkNewAccelGyroData 00000024  00000000  00000000  00001d70  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 24 .text.checkWakeOnMotion 00000024  00000000  00000000  00001d94  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 25 .text.initializeMPU9250Parameters 00000028  00000000  00000000  00001db8  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 26 .text.updateTime 0000004c  00000000  00000000  00001de0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 27 .text.delay   00000018  00000000  00000000  00001e2c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 28 .debug_info   00000ae3  00000000  00000000  00001e44  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 29 .debug_abbrev 00000203  00000000  00000000  00002927  2**0                  CONTENTS, READONLY, DEBUGGING 30 .debug_loc    0000050a  00000000  00000000  00002b2a  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 31 .debug_aranges 000000d8  00000000  00000000  00003034  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 32 .debug_macinfo 0002a298  00000000  00000000  0000310c  2**0                  CONTENTS, READONLY, DEBUGGING 33 .debug_line   00000716  00000000  00000000  0002d3a4  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 34 .debug_str    00000589  00000000  00000000  0002daba  2**0                  CONTENTS, READONLY, DEBUGGING 35 .comment      0000007a  00000000  00000000  0002e043  2**0                  CONTENTS, READONLY 36 .ARM.attributes 00000031  00000000  00000000  0002e0bd  2**0                  CONTENTS, READONLY 37 .debug_frame  00000308  00000000  00000000  0002e0f0  2**2                  CONTENTS, RELOC, READONLY, DEBUGGINGSYMBOL TABLE:00000000 l    df *ABS*	00000000 MPU9250.c00000000 l    d  .text	00000000 .text00000000 l    d  .data	00000000 .data00000000 l    d  .bss	00000000 .bss00000000 l    d  .text.getMres	00000000 .text.getMres00000000 l    d  .text.getGres	00000000 .text.getGres00000000 l    d  .text.getAres	00000000 .text.getAres00000000 l    d  .text.readAccelData	00000000 .text.readAccelData00000000 l    d  .text.readGyroData	00000000 .text.readGyroData00000000 l    d  .text.readMagData	00000000 .text.readMagData00000000 l    d  .text.readTempData	00000000 .text.readTempData00000000 l    d  .text.initAK8963	00000000 .text.initAK896300000000 l    d  .text.initMPU9250	00000000 .text.initMPU925000000000 l    d  .text.MPU9250SelfTest	00000000 .text.MPU9250SelfTest00000000 l    d  .rodata	00000000 .rodata00000000 l    d  .text.magcalMPU9250	00000000 .text.magcalMPU925000000000 l    d  .text.calibrateMPU9250	00000000 .text.calibrateMPU925000000000 l    d  .text.readData	00000000 .text.readData00000000 l    d  .text.accelWakeOnMotion	00000000 .text.accelWakeOnMotion00000000 l    d  .text.gyromagSleep	00000000 .text.gyromagSleep00000000 l    d  .text.gyromagWake	00000000 .text.gyromagWake00000000 l    d  .text.resetMPU9250	00000000 .text.resetMPU925000000000 l    d  .text.readMPU9250Data	00000000 .text.readMPU9250Data00000000 l    d  .text.checkNewMagData	00000000 .text.checkNewMagData00000000 l    d  .text.checkNewAccelGyroData	00000000 .text.checkNewAccelGyroData00000000 l    d  .text.checkWakeOnMotion	00000000 .text.checkWakeOnMotion00000000 l    d  .text.initializeMPU9250Parameters	00000000 .text.initializeMPU9250Parameters00000000 l    d  .text.updateTime	00000000 .text.updateTime00000000 l    d  .text.delay	00000000 .text.delay00000000 l    d  .debug_info	00000000 .debug_info00000000 l    d  .debug_abbrev	00000000 .debug_abbrev00000000 l    d  .debug_loc	00000000 .debug_loc00000000 l    d  .debug_aranges	00000000 .debug_aranges00000000 l    d  .debug_macinfo	00000000 .debug_macinfo00000000 l    d  .debug_line	00000000 .debug_line00000000 l    d  .debug_str	00000000 .debug_str00000000 l    d  .debug_frame	00000000 .debug_frame00000000 l    d  .comment	00000000 .comment00000000 l    d  .ARM.attributes	00000000 .ARM.attributes00000000 g     F .text.getMres	00000034 getMres00000000         *UND*	00000000 mpu925000000000 g     F .text.getGres	00000058 getGres00000000 g     F .text.getAres	00000050 getAres00000000 g     F .text.readAccelData	00000068 readAccelData00000000         *UND*	00000000 readBytes00000000 g     F .text.readGyroData	00000068 readGyroData00000000 g     F .text.readMagData	00000092 readMagData00000000         *UND*	00000000 readByte00000000 g     F .text.readTempData	0000002c readTempData00000000         *UND*	00000000 __aeabi_i2f00000000         *UND*	00000000 __aeabi_f2d00000000         *UND*	00000000 __aeabi_ddiv00000000         *UND*	00000000 __aeabi_dadd00000000         *UND*	00000000 __aeabi_d2f00000000 g     F .text.initAK8963	00000164 initAK896300000000         *UND*	00000000 writeByte00000000 g     F .text.delay	00000016 delay00000000 g     F .text.initMPU9250	00000118 initMPU925000000000         *UND*	00000000 __aeabi_idiv00000000         *UND*	00000000 __aeabi_ui2f00000000         *UND*	00000000 __aeabi_dsub00000000         *UND*	00000000 __aeabi_dmul00000000 g     F .text.MPU9250SelfTest	00000858 MPU9250SelfTest00000000         *UND*	00000000 pow00000000         *UND*	00000000 __aeabi_fmul00000000         *UND*	00000000 __aeabi_fdiv00000000 g     F .text.magcalMPU9250	00000370 magcalMPU925000000000         *UND*	00000000 memcpy00000000         *UND*	00000000 __aeabi_uidiv00000000 g     F .text.calibrateMPU9250	0000078e calibrateMPU925000000000         *UND*	00000000 __aeabi_fsub00000000         *UND*	00000000 __aeabi_fadd00000000 g     F .text.readData	0000027c readData00000000 g     F .text.accelWakeOnMotion	0000009e accelWakeOnMotion00000000 g     F .text.gyromagSleep	0000005c gyromagSleep00000000 g     F .text.gyromagWake	00000062 gyromagWake00000000 g     F .text.resetMPU9250	00000018 resetMPU925000000000 g     F .text.readMPU9250Data	000000d0 readMPU9250Data00000000 g     F .text.checkNewMagData	00000022 checkNewMagData00000000 g     F .text.checkNewAccelGyroData	00000022 checkNewAccelGyroData00000000 g     F .text.checkWakeOnMotion	00000022 checkWakeOnMotion00000000 g     F .text.initializeMPU9250Parameters	00000028 initializeMPU9250Parameters00000000 g     F .text.updateTime	0000004c updateTime00000000         *UND*	00000000 delayFuncDisassembly of section .text.getMres:00000000 <getMres>:Implementation of MPU9250 functions******************************/void getMres() {  // get magnetometer scale   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0  switch (mpu9250.Mscale)   4:	4b08      	ldr	r3, [pc, #32]	; (28 <getMres+0x28>)   6:	789b      	ldrb	r3, [r3, #2]   8:	2b00      	cmp	r3, #0   a:	d002      	beq.n	12 <getMres+0x12>   c:	2b01      	cmp	r3, #1   e:	d004      	beq.n	1a <getMres+0x1a>  10:	e007      	b.n	22 <getMres+0x22>  {  // Possible magnetometer scales (and their register bit settings) are:  // 14 bit resolution (0) and 16 bit resolution (1)    case MFS_14BITS:    	mpu9250.mRes = 10.*4912./8190.; // Proper scale to return milliGauss  12:	4b05      	ldr	r3, [pc, #20]	; (28 <getMres+0x28>)  14:	4a05      	ldr	r2, [pc, #20]	; (2c <getMres+0x2c>)  16:	64da      	str	r2, [r3, #76]	; 0x4c          break;  18:	e003      	b.n	22 <getMres+0x22>    case MFS_16BITS:    	mpu9250.mRes = 10.*4912./32760.0; // Proper scale to return milliGauss  1a:	4b03      	ldr	r3, [pc, #12]	; (28 <getMres+0x28>)  1c:	4a04      	ldr	r2, [pc, #16]	; (30 <getMres+0x30>)  1e:	64da      	str	r2, [r3, #76]	; 0x4c          break;  20:	46c0      	nop			; (mov r8, r8)  }}  22:	46bd      	mov	sp, r7  24:	bd80      	pop	{r7, pc}  26:	46c0      	nop			; (mov r8, r8)  28:	00000000 	.word	0x00000000			28: R_ARM_ABS32	mpu9250  2c:	40bfebff 	.word	0x40bfebff  30:	3fbfebff 	.word	0x3fbfebffDisassembly of section .text.getGres:00000000 <getGres>:void getGres() {  // get gyro scale   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0  switch (mpu9250.Gscale)   4:	4b0f      	ldr	r3, [pc, #60]	; (44 <getGres+0x44>)   6:	781b      	ldrb	r3, [r3, #0]   8:	2b01      	cmp	r3, #1   a:	d00c      	beq.n	26 <getGres+0x26>   c:	dc02      	bgt.n	14 <getGres+0x14>   e:	2b00      	cmp	r3, #0  10:	d005      	beq.n	1e <getGres+0x1e>  12:	e014      	b.n	3e <getGres+0x3e>  14:	2b02      	cmp	r3, #2  16:	d00a      	beq.n	2e <getGres+0x2e>  18:	2b03      	cmp	r3, #3  1a:	d00c      	beq.n	36 <getGres+0x36>  1c:	e00f      	b.n	3e <getGres+0x3e>  {  // Possible gyro scales (and their register bit settings) are:  // 250 DPS (00), 500 DPS (01), 1000 DPS (10), and 2000 DPS  (11).         // Here's a bit of an algorith to calculate DPS/(ADC tick) based on that 2-bit value:    case GFS_250DPS:    	  mpu9250.gRes = 250.0/32768.0;  1e:	4b09      	ldr	r3, [pc, #36]	; (44 <getGres+0x44>)  20:	4a09      	ldr	r2, [pc, #36]	; (48 <getGres+0x48>)  22:	649a      	str	r2, [r3, #72]	; 0x48          break;  24:	e00b      	b.n	3e <getGres+0x3e>    case GFS_500DPS:    	  mpu9250.gRes = 500.0/32768.0;  26:	4b07      	ldr	r3, [pc, #28]	; (44 <getGres+0x44>)  28:	4a08      	ldr	r2, [pc, #32]	; (4c <getGres+0x4c>)  2a:	649a      	str	r2, [r3, #72]	; 0x48          break;  2c:	e007      	b.n	3e <getGres+0x3e>    case GFS_1000DPS:    	  mpu9250.gRes = 1000.0/32768.0;  2e:	4b05      	ldr	r3, [pc, #20]	; (44 <getGres+0x44>)  30:	4a07      	ldr	r2, [pc, #28]	; (50 <getGres+0x50>)  32:	649a      	str	r2, [r3, #72]	; 0x48          break;  34:	e003      	b.n	3e <getGres+0x3e>    case GFS_2000DPS:    	  mpu9250.gRes = 2000.0/32768.0;  36:	4b03      	ldr	r3, [pc, #12]	; (44 <getGres+0x44>)  38:	4a06      	ldr	r2, [pc, #24]	; (54 <getGres+0x54>)  3a:	649a      	str	r2, [r3, #72]	; 0x48          break;  3c:	46c0      	nop			; (mov r8, r8)  }}  3e:	46bd      	mov	sp, r7  40:	bd80      	pop	{r7, pc}  42:	46c0      	nop			; (mov r8, r8)  44:	00000000 	.word	0x00000000			44: R_ARM_ABS32	mpu9250  48:	3bfa0000 	.word	0x3bfa0000  4c:	3c7a0000 	.word	0x3c7a0000  50:	3cfa0000 	.word	0x3cfa0000  54:	3d7a0000 	.word	0x3d7a0000Disassembly of section .text.getAres:00000000 <getAres>:void getAres() {   // get accelerometer scale   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0  switch (mpu9250.Ascale)   4:	4b11      	ldr	r3, [pc, #68]	; (4c <getAres+0x4c>)   6:	785b      	ldrb	r3, [r3, #1]   8:	2b01      	cmp	r3, #1   a:	d00d      	beq.n	28 <getAres+0x28>   c:	dc02      	bgt.n	14 <getAres+0x14>   e:	2b00      	cmp	r3, #0  10:	d005      	beq.n	1e <getAres+0x1e>  12:	e018      	b.n	46 <getAres+0x46>  14:	2b02      	cmp	r3, #2  16:	d00c      	beq.n	32 <getAres+0x32>  18:	2b03      	cmp	r3, #3  1a:	d00f      	beq.n	3c <getAres+0x3c>  1c:	e013      	b.n	46 <getAres+0x46>  {  // Possible accelerometer scales (and their register bit settings) are:  // 2 Gs (00), 4 Gs (01), 8 Gs (10), and 16 Gs  (11).         // Here's a bit of an algorith to calculate DPS/(ADC tick) based on that 2-bit value:    case AFS_2G:    	  mpu9250.aRes = 2.0/32768.0;  1e:	4b0b      	ldr	r3, [pc, #44]	; (4c <getAres+0x4c>)  20:	22e2      	movs	r2, #226	; 0xe2  22:	0592      	lsls	r2, r2, #22  24:	645a      	str	r2, [r3, #68]	; 0x44          break;  26:	e00e      	b.n	46 <getAres+0x46>    case AFS_4G:    	  mpu9250.aRes = 4.0/32768.0;  28:	4b08      	ldr	r3, [pc, #32]	; (4c <getAres+0x4c>)  2a:	22e4      	movs	r2, #228	; 0xe4  2c:	0592      	lsls	r2, r2, #22  2e:	645a      	str	r2, [r3, #68]	; 0x44          break;  30:	e009      	b.n	46 <getAres+0x46>    case AFS_8G:    	  mpu9250.aRes = 8.0/32768.0;  32:	4b06      	ldr	r3, [pc, #24]	; (4c <getAres+0x4c>)  34:	22e6      	movs	r2, #230	; 0xe6  36:	0592      	lsls	r2, r2, #22  38:	645a      	str	r2, [r3, #68]	; 0x44          break;  3a:	e004      	b.n	46 <getAres+0x46>    case AFS_16G:    	  mpu9250.aRes = 16.0/32768.0;  3c:	4b03      	ldr	r3, [pc, #12]	; (4c <getAres+0x4c>)  3e:	22e8      	movs	r2, #232	; 0xe8  40:	0592      	lsls	r2, r2, #22  42:	645a      	str	r2, [r3, #68]	; 0x44          break;  44:	46c0      	nop			; (mov r8, r8)  }}  46:	46bd      	mov	sp, r7  48:	bd80      	pop	{r7, pc}  4a:	46c0      	nop			; (mov r8, r8)  4c:	00000000 	.word	0x00000000			4c: R_ARM_ABS32	mpu9250Disassembly of section .text.readAccelData:00000000 <readAccelData>:void readAccelData(int16_t * destination){   0:	b580      	push	{r7, lr}   2:	b084      	sub	sp, #16   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]  uint8_t rawData[6];  // x/y/z accel register data stored here  readBytes(MPU9250_ADDRESS, ACCEL_XOUT_H, 6, &rawData[0]);  // Read the six raw data registers into data array   8:	1c3b      	adds	r3, r7, #0   a:	3308      	adds	r3, #8   c:	2068      	movs	r0, #104	; 0x68   e:	213b      	movs	r1, #59	; 0x3b  10:	2206      	movs	r2, #6  12:	f7ff fffe 	bl	0 <readBytes>			12: R_ARM_THM_CALL	readBytes  destination[0] = ((int16_t)rawData[0] << 8) | rawData[1] ;  // Turn the MSB and LSB into a signed 16-bit value  16:	1c3b      	adds	r3, r7, #0  18:	3308      	adds	r3, #8  1a:	781b      	ldrb	r3, [r3, #0]  1c:	021b      	lsls	r3, r3, #8  1e:	b29a      	uxth	r2, r3  20:	1c3b      	adds	r3, r7, #0  22:	3308      	adds	r3, #8  24:	785b      	ldrb	r3, [r3, #1]  26:	4313      	orrs	r3, r2  28:	b29a      	uxth	r2, r3  2a:	687b      	ldr	r3, [r7, #4]  2c:	801a      	strh	r2, [r3, #0]  destination[1] = ((int16_t)rawData[2] << 8) | rawData[3] ;    2e:	687b      	ldr	r3, [r7, #4]  30:	3302      	adds	r3, #2  32:	1c3a      	adds	r2, r7, #0  34:	3208      	adds	r2, #8  36:	7892      	ldrb	r2, [r2, #2]  38:	0212      	lsls	r2, r2, #8  3a:	b291      	uxth	r1, r2  3c:	1c3a      	adds	r2, r7, #0  3e:	3208      	adds	r2, #8  40:	78d2      	ldrb	r2, [r2, #3]  42:	430a      	orrs	r2, r1  44:	b292      	uxth	r2, r2  46:	801a      	strh	r2, [r3, #0]  destination[2] = ((int16_t)rawData[4] << 8) | rawData[5] ;   48:	687b      	ldr	r3, [r7, #4]  4a:	3304      	adds	r3, #4  4c:	1c3a      	adds	r2, r7, #0  4e:	3208      	adds	r2, #8  50:	7912      	ldrb	r2, [r2, #4]  52:	0212      	lsls	r2, r2, #8  54:	b291      	uxth	r1, r2  56:	1c3a      	adds	r2, r7, #0  58:	3208      	adds	r2, #8  5a:	7952      	ldrb	r2, [r2, #5]  5c:	430a      	orrs	r2, r1  5e:	b292      	uxth	r2, r2  60:	801a      	strh	r2, [r3, #0]}  62:	46bd      	mov	sp, r7  64:	b004      	add	sp, #16  66:	bd80      	pop	{r7, pc}Disassembly of section .text.readGyroData:00000000 <readGyroData>:void readGyroData(int16_t * destination){   0:	b580      	push	{r7, lr}   2:	b084      	sub	sp, #16   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]  uint8_t rawData[6];  // x/y/z gyro register data stored here  readBytes(MPU9250_ADDRESS, GYRO_XOUT_H, 6, &rawData[0]);  // Read the six raw data registers sequentially into data array   8:	1c3b      	adds	r3, r7, #0   a:	3308      	adds	r3, #8   c:	2068      	movs	r0, #104	; 0x68   e:	2143      	movs	r1, #67	; 0x43  10:	2206      	movs	r2, #6  12:	f7ff fffe 	bl	0 <readBytes>			12: R_ARM_THM_CALL	readBytes  destination[0] = ((int16_t)rawData[0] << 8) | rawData[1] ;  // Turn the MSB and LSB into a signed 16-bit value  16:	1c3b      	adds	r3, r7, #0  18:	3308      	adds	r3, #8  1a:	781b      	ldrb	r3, [r3, #0]  1c:	021b      	lsls	r3, r3, #8  1e:	b29a      	uxth	r2, r3  20:	1c3b      	adds	r3, r7, #0  22:	3308      	adds	r3, #8  24:	785b      	ldrb	r3, [r3, #1]  26:	4313      	orrs	r3, r2  28:	b29a      	uxth	r2, r3  2a:	687b      	ldr	r3, [r7, #4]  2c:	801a      	strh	r2, [r3, #0]  destination[1] = ((int16_t)rawData[2] << 8) | rawData[3] ;    2e:	687b      	ldr	r3, [r7, #4]  30:	3302      	adds	r3, #2  32:	1c3a      	adds	r2, r7, #0  34:	3208      	adds	r2, #8  36:	7892      	ldrb	r2, [r2, #2]  38:	0212      	lsls	r2, r2, #8  3a:	b291      	uxth	r1, r2  3c:	1c3a      	adds	r2, r7, #0  3e:	3208      	adds	r2, #8  40:	78d2      	ldrb	r2, [r2, #3]  42:	430a      	orrs	r2, r1  44:	b292      	uxth	r2, r2  46:	801a      	strh	r2, [r3, #0]  destination[2] = ((int16_t)rawData[4] << 8) | rawData[5] ;   48:	687b      	ldr	r3, [r7, #4]  4a:	3304      	adds	r3, #4  4c:	1c3a      	adds	r2, r7, #0  4e:	3208      	adds	r2, #8  50:	7912      	ldrb	r2, [r2, #4]  52:	0212      	lsls	r2, r2, #8  54:	b291      	uxth	r1, r2  56:	1c3a      	adds	r2, r7, #0  58:	3208      	adds	r2, #8  5a:	7952      	ldrb	r2, [r2, #5]  5c:	430a      	orrs	r2, r1  5e:	b292      	uxth	r2, r2  60:	801a      	strh	r2, [r3, #0]}  62:	46bd      	mov	sp, r7  64:	b004      	add	sp, #16  66:	bd80      	pop	{r7, pc}Disassembly of section .text.readMagData:00000000 <readMagData>:void readMagData(int16_t * destination){   0:	b580      	push	{r7, lr}   2:	b084      	sub	sp, #16   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]  // x/y/z gyro register data, ST2 register stored here, must read ST2 at end of  // data acquisition  uint8_t rawData[7];  // Wait for magnetometer data ready bit to be set  if(readByte(AK8963_ADDRESS, AK8963_ST1) & 0x01)   8:	200c      	movs	r0, #12   a:	2102      	movs	r1, #2   c:	f7ff fffe 	bl	0 <readByte>			c: R_ARM_THM_CALL	readByte  10:	1c03      	adds	r3, r0, #0  12:	1c1a      	adds	r2, r3, #0  14:	2301      	movs	r3, #1  16:	4013      	ands	r3, r2  18:	d038      	beq.n	8c <readMagData+0x8c>  {    // Read the six raw data and ST2 registers sequentially into data array    readBytes(AK8963_ADDRESS, AK8963_XOUT_L, 7, &rawData[0]);  1a:	1c3b      	adds	r3, r7, #0  1c:	3308      	adds	r3, #8  1e:	200c      	movs	r0, #12  20:	2103      	movs	r1, #3  22:	2207      	movs	r2, #7  24:	f7ff fffe 	bl	0 <readBytes>			24: R_ARM_THM_CALL	readBytes    uint8_t c = rawData[6]; // End data read by reading ST2 register  28:	1c3b      	adds	r3, r7, #0  2a:	330f      	adds	r3, #15  2c:	1c3a      	adds	r2, r7, #0  2e:	3208      	adds	r2, #8  30:	7992      	ldrb	r2, [r2, #6]  32:	701a      	strb	r2, [r3, #0]    // Check if magnetic sensor overflow set, if not then report data    if(!(c & 0x08))  34:	1c3b      	adds	r3, r7, #0  36:	330f      	adds	r3, #15  38:	781a      	ldrb	r2, [r3, #0]  3a:	2308      	movs	r3, #8  3c:	4013      	ands	r3, r2  3e:	d125      	bne.n	8c <readMagData+0x8c>    {      // Turn the MSB and LSB into a signed 16-bit value      destination[0] = ((int16_t)rawData[1] << 8) | rawData[0];  40:	1c3b      	adds	r3, r7, #0  42:	3308      	adds	r3, #8  44:	785b      	ldrb	r3, [r3, #1]  46:	021b      	lsls	r3, r3, #8  48:	b29a      	uxth	r2, r3  4a:	1c3b      	adds	r3, r7, #0  4c:	3308      	adds	r3, #8  4e:	781b      	ldrb	r3, [r3, #0]  50:	4313      	orrs	r3, r2  52:	b29a      	uxth	r2, r3  54:	687b      	ldr	r3, [r7, #4]  56:	801a      	strh	r2, [r3, #0]      // Data stored as little Endian       destination[1] = ((int16_t)rawData[3] << 8) | rawData[2];  58:	687b      	ldr	r3, [r7, #4]  5a:	3302      	adds	r3, #2  5c:	1c3a      	adds	r2, r7, #0  5e:	3208      	adds	r2, #8  60:	78d2      	ldrb	r2, [r2, #3]  62:	0212      	lsls	r2, r2, #8  64:	b291      	uxth	r1, r2  66:	1c3a      	adds	r2, r7, #0  68:	3208      	adds	r2, #8  6a:	7892      	ldrb	r2, [r2, #2]  6c:	430a      	orrs	r2, r1  6e:	b292      	uxth	r2, r2  70:	801a      	strh	r2, [r3, #0]      destination[2] = ((int16_t)rawData[5] << 8) | rawData[4];  72:	687b      	ldr	r3, [r7, #4]  74:	3304      	adds	r3, #4  76:	1c3a      	adds	r2, r7, #0  78:	3208      	adds	r2, #8  7a:	7952      	ldrb	r2, [r2, #5]  7c:	0212      	lsls	r2, r2, #8  7e:	b291      	uxth	r1, r2  80:	1c3a      	adds	r2, r7, #0  82:	3208      	adds	r2, #8  84:	7912      	ldrb	r2, [r2, #4]  86:	430a      	orrs	r2, r1  88:	b292      	uxth	r2, r2  8a:	801a      	strh	r2, [r3, #0]    }  }}  8c:	46bd      	mov	sp, r7  8e:	b004      	add	sp, #16  90:	bd80      	pop	{r7, pc}  92:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.readTempData:00000000 <readTempData>:int16_t readTempData(){   0:	b580      	push	{r7, lr}   2:	b082      	sub	sp, #8   4:	af00      	add	r7, sp, #0  uint8_t rawData[2];  // x/y/z gyro register data stored here  readBytes(MPU9250_ADDRESS, TEMP_OUT_H, 2, &rawData[0]);  // Read the two raw data registers sequentially into data array    6:	1d3b      	adds	r3, r7, #4   8:	2068      	movs	r0, #104	; 0x68   a:	2141      	movs	r1, #65	; 0x41   c:	2202      	movs	r2, #2   e:	f7ff fffe 	bl	0 <readBytes>			e: R_ARM_THM_CALL	readBytes  return ((int16_t)rawData[0] << 8) | rawData[1];  // Turn the MSB and LSB into a 16-bit value  12:	1d3b      	adds	r3, r7, #4  14:	781b      	ldrb	r3, [r3, #0]  16:	021b      	lsls	r3, r3, #8  18:	b29a      	uxth	r2, r3  1a:	1d3b      	adds	r3, r7, #4  1c:	785b      	ldrb	r3, [r3, #1]  1e:	4313      	orrs	r3, r2  20:	b29b      	uxth	r3, r3  22:	b21b      	sxth	r3, r3}  24:	1c18      	adds	r0, r3, #0  26:	46bd      	mov	sp, r7  28:	b002      	add	sp, #8  2a:	bd80      	pop	{r7, pc}Disassembly of section .text.initAK8963:00000000 <initAK8963>:void initAK8963(float * destination){   0:	b5b0      	push	{r4, r5, r7, lr}   2:	b084      	sub	sp, #16   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]  // First extract the factory calibration for each magnetometer axis  uint8_t rawData[3];  // x/y/z gyro calibration data stored here  writeByte(AK8963_ADDRESS, AK8963_CNTL, 0x00); // Power down magnetometer     8:	200c      	movs	r0, #12   a:	210a      	movs	r1, #10   c:	2200      	movs	r2, #0   e:	f7ff fffe 	bl	0 <writeByte>			e: R_ARM_THM_CALL	writeByte  delay(10);  12:	200a      	movs	r0, #10  14:	f7ff fffe 	bl	0 <initAK8963>			14: R_ARM_THM_CALL	delay  writeByte(AK8963_ADDRESS, AK8963_CNTL, 0x0F); // Enter Fuse ROM access mode  18:	200c      	movs	r0, #12  1a:	210a      	movs	r1, #10  1c:	220f      	movs	r2, #15  1e:	f7ff fffe 	bl	0 <writeByte>			1e: R_ARM_THM_CALL	writeByte  delay(10);  22:	200a      	movs	r0, #10  24:	f7ff fffe 	bl	0 <initAK8963>			24: R_ARM_THM_CALL	delay  readBytes(AK8963_ADDRESS, AK8963_ASAX, 3, &rawData[0]);  // Read the x-, y-, and z-axis calibration values  28:	1c3b      	adds	r3, r7, #0  2a:	330c      	adds	r3, #12  2c:	200c      	movs	r0, #12  2e:	2110      	movs	r1, #16  30:	2203      	movs	r2, #3  32:	f7ff fffe 	bl	0 <readBytes>			32: R_ARM_THM_CALL	readBytes  destination[0] =  (float)(rawData[0] - 128)/256. + 1.;   // Return x-axis sensitivity adjustment values, etc.  36:	1c3b      	adds	r3, r7, #0  38:	330c      	adds	r3, #12  3a:	781b      	ldrb	r3, [r3, #0]  3c:	3b80      	subs	r3, #128	; 0x80  3e:	1c18      	adds	r0, r3, #0  40:	f7ff fffe 	bl	0 <__aeabi_i2f>			40: R_ARM_THM_CALL	__aeabi_i2f  44:	1c03      	adds	r3, r0, #0  46:	1c18      	adds	r0, r3, #0  48:	f7ff fffe 	bl	0 <__aeabi_f2d>			48: R_ARM_THM_CALL	__aeabi_f2d  4c:	1c03      	adds	r3, r0, #0  4e:	1c0c      	adds	r4, r1, #0  50:	1c18      	adds	r0, r3, #0  52:	1c21      	adds	r1, r4, #0  54:	4b3f      	ldr	r3, [pc, #252]	; (154 <initAK8963+0x154>)  56:	4a3e      	ldr	r2, [pc, #248]	; (150 <initAK8963+0x150>)  58:	f7ff fffe 	bl	0 <__aeabi_ddiv>			58: R_ARM_THM_CALL	__aeabi_ddiv  5c:	1c03      	adds	r3, r0, #0  5e:	1c0c      	adds	r4, r1, #0  60:	1c18      	adds	r0, r3, #0  62:	1c21      	adds	r1, r4, #0  64:	4a3c      	ldr	r2, [pc, #240]	; (158 <initAK8963+0x158>)  66:	4b3d      	ldr	r3, [pc, #244]	; (15c <initAK8963+0x15c>)  68:	f7ff fffe 	bl	0 <__aeabi_dadd>			68: R_ARM_THM_CALL	__aeabi_dadd  6c:	1c03      	adds	r3, r0, #0  6e:	1c0c      	adds	r4, r1, #0  70:	1c18      	adds	r0, r3, #0  72:	1c21      	adds	r1, r4, #0  74:	f7ff fffe 	bl	0 <__aeabi_d2f>			74: R_ARM_THM_CALL	__aeabi_d2f  78:	1c02      	adds	r2, r0, #0  7a:	687b      	ldr	r3, [r7, #4]  7c:	601a      	str	r2, [r3, #0]  destination[1] =  (float)(rawData[1] - 128)/256. + 1.;    7e:	687b      	ldr	r3, [r7, #4]  80:	1d1d      	adds	r5, r3, #4  82:	1c3b      	adds	r3, r7, #0  84:	330c      	adds	r3, #12  86:	785b      	ldrb	r3, [r3, #1]  88:	3b80      	subs	r3, #128	; 0x80  8a:	1c18      	adds	r0, r3, #0  8c:	f7ff fffe 	bl	0 <__aeabi_i2f>			8c: R_ARM_THM_CALL	__aeabi_i2f  90:	1c03      	adds	r3, r0, #0  92:	1c18      	adds	r0, r3, #0  94:	f7ff fffe 	bl	0 <__aeabi_f2d>			94: R_ARM_THM_CALL	__aeabi_f2d  98:	1c03      	adds	r3, r0, #0  9a:	1c0c      	adds	r4, r1, #0  9c:	1c18      	adds	r0, r3, #0  9e:	1c21      	adds	r1, r4, #0  a0:	4b2c      	ldr	r3, [pc, #176]	; (154 <initAK8963+0x154>)  a2:	4a2b      	ldr	r2, [pc, #172]	; (150 <initAK8963+0x150>)  a4:	f7ff fffe 	bl	0 <__aeabi_ddiv>			a4: R_ARM_THM_CALL	__aeabi_ddiv  a8:	1c03      	adds	r3, r0, #0  aa:	1c0c      	adds	r4, r1, #0  ac:	1c18      	adds	r0, r3, #0  ae:	1c21      	adds	r1, r4, #0  b0:	4a29      	ldr	r2, [pc, #164]	; (158 <initAK8963+0x158>)  b2:	4b2a      	ldr	r3, [pc, #168]	; (15c <initAK8963+0x15c>)  b4:	f7ff fffe 	bl	0 <__aeabi_dadd>			b4: R_ARM_THM_CALL	__aeabi_dadd  b8:	1c03      	adds	r3, r0, #0  ba:	1c0c      	adds	r4, r1, #0  bc:	1c18      	adds	r0, r3, #0  be:	1c21      	adds	r1, r4, #0  c0:	f7ff fffe 	bl	0 <__aeabi_d2f>			c0: R_ARM_THM_CALL	__aeabi_d2f  c4:	1c03      	adds	r3, r0, #0  c6:	602b      	str	r3, [r5, #0]  destination[2] =  (float)(rawData[2] - 128)/256. + 1.;   c8:	687b      	ldr	r3, [r7, #4]  ca:	1c1d      	adds	r5, r3, #0  cc:	3508      	adds	r5, #8  ce:	1c3b      	adds	r3, r7, #0  d0:	330c      	adds	r3, #12  d2:	789b      	ldrb	r3, [r3, #2]  d4:	3b80      	subs	r3, #128	; 0x80  d6:	1c18      	adds	r0, r3, #0  d8:	f7ff fffe 	bl	0 <__aeabi_i2f>			d8: R_ARM_THM_CALL	__aeabi_i2f  dc:	1c03      	adds	r3, r0, #0  de:	1c18      	adds	r0, r3, #0  e0:	f7ff fffe 	bl	0 <__aeabi_f2d>			e0: R_ARM_THM_CALL	__aeabi_f2d  e4:	1c03      	adds	r3, r0, #0  e6:	1c0c      	adds	r4, r1, #0  e8:	1c18      	adds	r0, r3, #0  ea:	1c21      	adds	r1, r4, #0  ec:	4b19      	ldr	r3, [pc, #100]	; (154 <initAK8963+0x154>)  ee:	4a18      	ldr	r2, [pc, #96]	; (150 <initAK8963+0x150>)  f0:	f7ff fffe 	bl	0 <__aeabi_ddiv>			f0: R_ARM_THM_CALL	__aeabi_ddiv  f4:	1c03      	adds	r3, r0, #0  f6:	1c0c      	adds	r4, r1, #0  f8:	1c18      	adds	r0, r3, #0  fa:	1c21      	adds	r1, r4, #0  fc:	4a16      	ldr	r2, [pc, #88]	; (158 <initAK8963+0x158>)  fe:	4b17      	ldr	r3, [pc, #92]	; (15c <initAK8963+0x15c>) 100:	f7ff fffe 	bl	0 <__aeabi_dadd>			100: R_ARM_THM_CALL	__aeabi_dadd 104:	1c03      	adds	r3, r0, #0 106:	1c0c      	adds	r4, r1, #0 108:	1c18      	adds	r0, r3, #0 10a:	1c21      	adds	r1, r4, #0 10c:	f7ff fffe 	bl	0 <__aeabi_d2f>			10c: R_ARM_THM_CALL	__aeabi_d2f 110:	1c03      	adds	r3, r0, #0 112:	602b      	str	r3, [r5, #0]  writeByte(AK8963_ADDRESS, AK8963_CNTL, 0x00); // Power down magnetometer   114:	200c      	movs	r0, #12 116:	210a      	movs	r1, #10 118:	2200      	movs	r2, #0 11a:	f7ff fffe 	bl	0 <writeByte>			11a: R_ARM_THM_CALL	writeByte  delay(10); 11e:	200a      	movs	r0, #10 120:	f7ff fffe 	bl	0 <initAK8963>			120: R_ARM_THM_CALL	delay  // Configure the magnetometer for continuous read and highest resolution  // set Mscale bit 4 to 1 (0) to enable 16 (14) bit resolution in CNTL register,  // and enable continuous mode data acquisition Mmode (bits [3:0]), 0010 for 8 Hz and 0110 for 100 Hz sample rates  writeByte(AK8963_ADDRESS, AK8963_CNTL, mpu9250.Mscale << 4 | mpu9250.Mmode); // Set magnetometer data resolution and sample ODR 124:	4b0e      	ldr	r3, [pc, #56]	; (160 <initAK8963+0x160>) 126:	789b      	ldrb	r3, [r3, #2] 128:	011b      	lsls	r3, r3, #4 12a:	b2da      	uxtb	r2, r3 12c:	4b0c      	ldr	r3, [pc, #48]	; (160 <initAK8963+0x160>) 12e:	78db      	ldrb	r3, [r3, #3] 130:	b2db      	uxtb	r3, r3 132:	4313      	orrs	r3, r2 134:	b2db      	uxtb	r3, r3 136:	b2db      	uxtb	r3, r3 138:	200c      	movs	r0, #12 13a:	210a      	movs	r1, #10 13c:	1c1a      	adds	r2, r3, #0 13e:	f7ff fffe 	bl	0 <writeByte>			13e: R_ARM_THM_CALL	writeByte  delay(10); 142:	200a      	movs	r0, #10 144:	f7ff fffe 	bl	0 <initAK8963>			144: R_ARM_THM_CALL	delay} 148:	46bd      	mov	sp, r7 14a:	b004      	add	sp, #16 14c:	bdb0      	pop	{r4, r5, r7, pc} 14e:	46c0      	nop			; (mov r8, r8) 150:	00000000 	.word	0x00000000 154:	40700000 	.word	0x40700000 158:	00000000 	.word	0x00000000 15c:	3ff00000 	.word	0x3ff00000 160:	00000000 	.word	0x00000000			160: R_ARM_ABS32	mpu9250 164:	46c0      	nop			; (mov r8, r8) 166:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.initMPU9250:00000000 <initMPU9250>:void initMPU9250(){     0:	b083b590 	.word	0xb083b590   4:	af00      	add	r7, sp, #0 // wake up device  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x00); // Clear sleep mode bit (6), enable all sensors    6:	2068      	movs	r0, #104	; 0x68   8:	216b      	movs	r1, #107	; 0x6b   a:	2200      	movs	r2, #0   c:	f7ff fffe 	bl	0 <writeByte>			c: R_ARM_THM_CALL	writeByte  delay(100); // Wait for all registers to reset   10:	2064      	movs	r0, #100	; 0x64  12:	f7ff fffe 	bl	0 <initMPU9250>			12: R_ARM_THM_CALL	delay // get stable time source  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x01);  // Auto select clock source to be PLL gyroscope reference if ready else  16:	2068      	movs	r0, #104	; 0x68  18:	216b      	movs	r1, #107	; 0x6b  1a:	2201      	movs	r2, #1  1c:	f7ff fffe 	bl	0 <writeByte>			1c: R_ARM_THM_CALL	writeByte  delay(200);   20:	20c8      	movs	r0, #200	; 0xc8  22:	f7ff fffe 	bl	0 <initMPU9250>			22: R_ARM_THM_CALL	delay // Disable FSYNC and set thermometer and gyro bandwidth to 41 and 42 Hz, respectively;  // minimum delay time for this setting is 5.9 ms, which means sensor fusion update rates cannot // be higher than 1 / 0.0059 = 170 Hz // DLPF_CFG = bits 2:0 = 011; this limits the sample rate to 1000 Hz for both // With the MPU9250, it is possible to get gyro sample rates of 32 kHz (!), 8 kHz, or 1 kHz  writeByte(MPU9250_ADDRESS, CONFIG, 0x03);    26:	2068      	movs	r0, #104	; 0x68  28:	211a      	movs	r1, #26  2a:	2203      	movs	r2, #3  2c:	f7ff fffe 	bl	0 <writeByte>			2c: R_ARM_THM_CALL	writeByte // Set sample rate = gyroscope output rate/(1 + SMPLRT_DIV)  writeByte(MPU9250_ADDRESS, SMPLRT_DIV, 0x04);  // Use a 200 Hz rate; a rate consistent with the filter update rate   30:	2068      	movs	r0, #104	; 0x68  32:	2119      	movs	r1, #25  34:	2204      	movs	r2, #4  36:	f7ff fffe 	bl	0 <writeByte>			36: R_ARM_THM_CALL	writeByte                                    // determined inset in CONFIG above  // Set gyroscope full scale range // Range selects FS_SEL and AFS_SEL are 0 - 3, so 2-bit values are left-shifted into positions 4:3  uint8_t c = readByte(MPU9250_ADDRESS, GYRO_CONFIG); // get current GYRO_CONFIG register value  3a:	1dfc      	adds	r4, r7, #7  3c:	2068      	movs	r0, #104	; 0x68  3e:	211b      	movs	r1, #27  40:	f7ff fffe 	bl	0 <readByte>			40: R_ARM_THM_CALL	readByte  44:	1c03      	adds	r3, r0, #0  46:	7023      	strb	r3, [r4, #0] // c = c & ~0xE0; // Clear self-test bits [7:5]   c = c & ~0x02; // Clear Fchoice bits [1:0]   48:	1dfb      	adds	r3, r7, #7  4a:	1dfa      	adds	r2, r7, #7  4c:	7812      	ldrb	r2, [r2, #0]  4e:	2102      	movs	r1, #2  50:	438a      	bics	r2, r1  52:	701a      	strb	r2, [r3, #0]  c = c & ~0x18; // Clear AFS bits [4:3]  54:	1dfb      	adds	r3, r7, #7  56:	1dfa      	adds	r2, r7, #7  58:	7812      	ldrb	r2, [r2, #0]  5a:	2118      	movs	r1, #24  5c:	438a      	bics	r2, r1  5e:	701a      	strb	r2, [r3, #0]  c = c | mpu9250.Gscale << 3; // Set full scale range for the gyro  60:	4b2c      	ldr	r3, [pc, #176]	; (114 <initMPU9250+0x114>)  62:	781b      	ldrb	r3, [r3, #0]  64:	00db      	lsls	r3, r3, #3  66:	b2da      	uxtb	r2, r3  68:	1dfb      	adds	r3, r7, #7  6a:	781b      	ldrb	r3, [r3, #0]  6c:	4313      	orrs	r3, r2  6e:	b2da      	uxtb	r2, r3  70:	1dfb      	adds	r3, r7, #7  72:	701a      	strb	r2, [r3, #0] // c =| 0x00; // Set Fchoice for the gyro to 11 by writing its inverse to bits 1:0 of GYRO_CONFIG  writeByte(MPU9250_ADDRESS, GYRO_CONFIG, c ); // Write new GYRO_CONFIG value to register  74:	1dfb      	adds	r3, r7, #7  76:	781b      	ldrb	r3, [r3, #0]  78:	2068      	movs	r0, #104	; 0x68  7a:	211b      	movs	r1, #27  7c:	1c1a      	adds	r2, r3, #0  7e:	f7ff fffe 	bl	0 <writeByte>			7e: R_ARM_THM_CALL	writeByte   // Set accelerometer full-scale range configuration  c = readByte(MPU9250_ADDRESS, ACCEL_CONFIG); // get current ACCEL_CONFIG register value  82:	1dfc      	adds	r4, r7, #7  84:	2068      	movs	r0, #104	; 0x68  86:	211c      	movs	r1, #28  88:	f7ff fffe 	bl	0 <readByte>			88: R_ARM_THM_CALL	readByte  8c:	1c03      	adds	r3, r0, #0  8e:	7023      	strb	r3, [r4, #0] // c = c & ~0xE0; // Clear self-test bits [7:5]   c = c & ~0x18;  // Clear AFS bits [4:3]  90:	1dfb      	adds	r3, r7, #7  92:	1dfa      	adds	r2, r7, #7  94:	7812      	ldrb	r2, [r2, #0]  96:	2118      	movs	r1, #24  98:	438a      	bics	r2, r1  9a:	701a      	strb	r2, [r3, #0]  c = c | mpu9250.Ascale << 3; // Set full scale range for the accelerometer   9c:	4b1d      	ldr	r3, [pc, #116]	; (114 <initMPU9250+0x114>)  9e:	785b      	ldrb	r3, [r3, #1]  a0:	00db      	lsls	r3, r3, #3  a2:	b2da      	uxtb	r2, r3  a4:	1dfb      	adds	r3, r7, #7  a6:	781b      	ldrb	r3, [r3, #0]  a8:	4313      	orrs	r3, r2  aa:	b2da      	uxtb	r2, r3  ac:	1dfb      	adds	r3, r7, #7  ae:	701a      	strb	r2, [r3, #0]  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, c); // Write new ACCEL_CONFIG register value  b0:	1dfb      	adds	r3, r7, #7  b2:	781b      	ldrb	r3, [r3, #0]  b4:	2068      	movs	r0, #104	; 0x68  b6:	211c      	movs	r1, #28  b8:	1c1a      	adds	r2, r3, #0  ba:	f7ff fffe 	bl	0 <writeByte>			ba: R_ARM_THM_CALL	writeByte // Set accelerometer sample rate configuration // It is possible to get a 4 kHz sample rate from the accelerometer by choosing 1 for // accel_fchoice_b bit [3]; in this case the bandwidth is 1.13 kHz  c = readByte(MPU9250_ADDRESS, ACCEL_CONFIG2); // get current ACCEL_CONFIG2 register value  be:	1dfc      	adds	r4, r7, #7  c0:	2068      	movs	r0, #104	; 0x68  c2:	211d      	movs	r1, #29  c4:	f7ff fffe 	bl	0 <readByte>			c4: R_ARM_THM_CALL	readByte  c8:	1c03      	adds	r3, r0, #0  ca:	7023      	strb	r3, [r4, #0]  c = c & ~0x0F; // Clear accel_fchoice_b (bit 3) and A_DLPFG (bits [2:0])    cc:	1dfb      	adds	r3, r7, #7  ce:	1dfa      	adds	r2, r7, #7  d0:	7812      	ldrb	r2, [r2, #0]  d2:	210f      	movs	r1, #15  d4:	438a      	bics	r2, r1  d6:	701a      	strb	r2, [r3, #0]  c = c | 0x03;  // Set accelerometer rate to 1 kHz and bandwidth to 41 Hz  d8:	1dfb      	adds	r3, r7, #7  da:	1dfa      	adds	r2, r7, #7  dc:	7812      	ldrb	r2, [r2, #0]  de:	2103      	movs	r1, #3  e0:	430a      	orrs	r2, r1  e2:	701a      	strb	r2, [r3, #0]  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG2, c); // Write new ACCEL_CONFIG2 register value  e4:	1dfb      	adds	r3, r7, #7  e6:	781b      	ldrb	r3, [r3, #0]  e8:	2068      	movs	r0, #104	; 0x68  ea:	211d      	movs	r1, #29  ec:	1c1a      	adds	r2, r3, #0  ee:	f7ff fffe 	bl	0 <writeByte>			ee: R_ARM_THM_CALL	writeByte  // Configure Interrupts and Bypass Enable  // Set interrupt pin active high, push-pull, hold interrupt pin level HIGH until interrupt cleared,  // clear on read of INT_STATUS, and enable I2C_BYPASS_EN so additional chips   // can join the I2C bus and all can be controlled by the Arduino as master   writeByte(MPU9250_ADDRESS, INT_PIN_CFG, 0x22);      f2:	2068      	movs	r0, #104	; 0x68  f4:	2137      	movs	r1, #55	; 0x37  f6:	2222      	movs	r2, #34	; 0x22  f8:	f7ff fffe 	bl	0 <writeByte>			f8: R_ARM_THM_CALL	writeByte   writeByte(MPU9250_ADDRESS, INT_ENABLE, 0x01);  // Enable data ready (bit 0) interrupt  fc:	2068      	movs	r0, #104	; 0x68  fe:	2138      	movs	r1, #56	; 0x38 100:	2201      	movs	r2, #1 102:	f7ff fffe 	bl	0 <writeByte>			102: R_ARM_THM_CALL	writeByte   delay(100); 106:	2064      	movs	r0, #100	; 0x64 108:	f7ff fffe 	bl	0 <initMPU9250>			108: R_ARM_THM_CALL	delay} 10c:	46bd      	mov	sp, r7 10e:	b003      	add	sp, #12 110:	bd90      	pop	{r4, r7, pc} 112:	46c0      	nop			; (mov r8, r8) 114:	00000000 	.word	0x00000000			114: R_ARM_ABS32	mpu9250Disassembly of section .text.MPU9250SelfTest:00000000 <MPU9250SelfTest>:// Accelerometer and gyroscope self test; check calibration wrt factory settingsvoid MPU9250SelfTest(float * destination) // Should return percent deviation from factory trim values, +/- 14 or less deviation is a pass{   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	4647      	mov	r7, r8   4:	b480      	push	{r7}   6:	b096      	sub	sp, #88	; 0x58   8:	af00      	add	r7, sp, #0   a:	6078      	str	r0, [r7, #4]  uint8_t rawData[6] = {0, 0, 0, 0, 0, 0};   c:	1c3b      	adds	r3, r7, #0   e:	3348      	adds	r3, #72	; 0x48  10:	2200      	movs	r2, #0  12:	701a      	strb	r2, [r3, #0]  14:	1c3b      	adds	r3, r7, #0  16:	3348      	adds	r3, #72	; 0x48  18:	2200      	movs	r2, #0  1a:	705a      	strb	r2, [r3, #1]  1c:	1c3b      	adds	r3, r7, #0  1e:	3348      	adds	r3, #72	; 0x48  20:	2200      	movs	r2, #0  22:	709a      	strb	r2, [r3, #2]  24:	1c3b      	adds	r3, r7, #0  26:	3348      	adds	r3, #72	; 0x48  28:	2200      	movs	r2, #0  2a:	70da      	strb	r2, [r3, #3]  2c:	1c3b      	adds	r3, r7, #0  2e:	3348      	adds	r3, #72	; 0x48  30:	2200      	movs	r2, #0  32:	711a      	strb	r2, [r3, #4]  34:	1c3b      	adds	r3, r7, #0  36:	3348      	adds	r3, #72	; 0x48  38:	2200      	movs	r2, #0  3a:	715a      	strb	r2, [r3, #5]  uint8_t selfTest[6];  int16_t gAvg[3], aAvg[3], aSTAvg[3], gSTAvg[3];  float factoryTrim[6];  uint8_t FS = 0;  3c:	1c3b      	adds	r3, r7, #0  3e:	334f      	adds	r3, #79	; 0x4f  40:	2200      	movs	r2, #0  42:	701a      	strb	r2, [r3, #0]     writeByte(MPU9250_ADDRESS, SMPLRT_DIV, 0x00);    // Set gyro sample rate to 1 kHz  44:	2068      	movs	r0, #104	; 0x68  46:	2119      	movs	r1, #25  48:	2200      	movs	r2, #0  4a:	f7ff fffe 	bl	0 <writeByte>			4a: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, CONFIG, 0x02);        // Set gyro sample rate to 1 kHz and DLPF to 92 Hz  4e:	2068      	movs	r0, #104	; 0x68  50:	211a      	movs	r1, #26  52:	2202      	movs	r2, #2  54:	f7ff fffe 	bl	0 <writeByte>			54: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, GYRO_CONFIG, 1<<FS);  // Set full scale range for the gyro to 250 dps  58:	1c3b      	adds	r3, r7, #0  5a:	334f      	adds	r3, #79	; 0x4f  5c:	781b      	ldrb	r3, [r3, #0]  5e:	2201      	movs	r2, #1  60:	1c11      	adds	r1, r2, #0  62:	4099      	lsls	r1, r3  64:	1c0b      	adds	r3, r1, #0  66:	b2db      	uxtb	r3, r3  68:	2068      	movs	r0, #104	; 0x68  6a:	211b      	movs	r1, #27  6c:	1c1a      	adds	r2, r3, #0  6e:	f7ff fffe 	bl	0 <writeByte>			6e: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG2, 0x02); // Set accelerometer rate to 1 kHz and bandwidth to 92 Hz  72:	2068      	movs	r0, #104	; 0x68  74:	211d      	movs	r1, #29  76:	2202      	movs	r2, #2  78:	f7ff fffe 	bl	0 <writeByte>			78: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 1<<FS); // Set full scale range for the accelerometer to 2 g  7c:	1c3b      	adds	r3, r7, #0  7e:	334f      	adds	r3, #79	; 0x4f  80:	781b      	ldrb	r3, [r3, #0]  82:	2201      	movs	r2, #1  84:	1c11      	adds	r1, r2, #0  86:	4099      	lsls	r1, r3  88:	1c0b      	adds	r3, r1, #0  8a:	b2db      	uxtb	r3, r3  8c:	2068      	movs	r0, #104	; 0x68  8e:	211c      	movs	r1, #28  90:	1c1a      	adds	r2, r3, #0  92:	f7ff fffe 	bl	0 <writeByte>			92: R_ARM_THM_CALL	writeByte  int ii;  for(  ii = 0; ii < 200; ii++) {  // get average current values of gyro and acclerometer  96:	2300      	movs	r3, #0  98:	657b      	str	r3, [r7, #84]	; 0x54  9a:	e08e      	b.n	1ba <MPU9250SelfTest+0x1ba>      readBytes(MPU9250_ADDRESS, ACCEL_XOUT_H, 6, rawData);        // Read the six raw data registers into data array  9c:	1c3b      	adds	r3, r7, #0  9e:	3348      	adds	r3, #72	; 0x48  a0:	2068      	movs	r0, #104	; 0x68  a2:	213b      	movs	r1, #59	; 0x3b  a4:	2206      	movs	r2, #6  a6:	f7ff fffe 	bl	0 <readBytes>			a6: R_ARM_THM_CALL	readBytes    aAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value  aa:	1c3b      	adds	r3, r7, #0  ac:	3330      	adds	r3, #48	; 0x30  ae:	881b      	ldrh	r3, [r3, #0]  b0:	b29a      	uxth	r2, r3  b2:	1c3b      	adds	r3, r7, #0  b4:	3348      	adds	r3, #72	; 0x48  b6:	781b      	ldrb	r3, [r3, #0]  b8:	021b      	lsls	r3, r3, #8  ba:	b299      	uxth	r1, r3  bc:	1c3b      	adds	r3, r7, #0  be:	3348      	adds	r3, #72	; 0x48  c0:	785b      	ldrb	r3, [r3, #1]  c2:	430b      	orrs	r3, r1  c4:	b29b      	uxth	r3, r3  c6:	b29b      	uxth	r3, r3  c8:	18d3      	adds	r3, r2, r3  ca:	b29b      	uxth	r3, r3  cc:	b29a      	uxth	r2, r3  ce:	1c3b      	adds	r3, r7, #0  d0:	3330      	adds	r3, #48	; 0x30  d2:	801a      	strh	r2, [r3, #0]    aAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;    d4:	1c3b      	adds	r3, r7, #0  d6:	3330      	adds	r3, #48	; 0x30  d8:	885b      	ldrh	r3, [r3, #2]  da:	b29a      	uxth	r2, r3  dc:	1c3b      	adds	r3, r7, #0  de:	3348      	adds	r3, #72	; 0x48  e0:	789b      	ldrb	r3, [r3, #2]  e2:	021b      	lsls	r3, r3, #8  e4:	b299      	uxth	r1, r3  e6:	1c3b      	adds	r3, r7, #0  e8:	3348      	adds	r3, #72	; 0x48  ea:	78db      	ldrb	r3, [r3, #3]  ec:	430b      	orrs	r3, r1  ee:	b29b      	uxth	r3, r3  f0:	b29b      	uxth	r3, r3  f2:	18d3      	adds	r3, r2, r3  f4:	b29b      	uxth	r3, r3  f6:	b29a      	uxth	r2, r3  f8:	1c3b      	adds	r3, r7, #0  fa:	3330      	adds	r3, #48	; 0x30  fc:	805a      	strh	r2, [r3, #2]    aAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;   fe:	1c3b      	adds	r3, r7, #0 100:	3330      	adds	r3, #48	; 0x30 102:	889b      	ldrh	r3, [r3, #4] 104:	b29a      	uxth	r2, r3 106:	1c3b      	adds	r3, r7, #0 108:	3348      	adds	r3, #72	; 0x48 10a:	791b      	ldrb	r3, [r3, #4] 10c:	021b      	lsls	r3, r3, #8 10e:	b299      	uxth	r1, r3 110:	1c3b      	adds	r3, r7, #0 112:	3348      	adds	r3, #72	; 0x48 114:	795b      	ldrb	r3, [r3, #5] 116:	430b      	orrs	r3, r1 118:	b29b      	uxth	r3, r3 11a:	b29b      	uxth	r3, r3 11c:	18d3      	adds	r3, r2, r3 11e:	b29b      	uxth	r3, r3 120:	b29a      	uxth	r2, r3 122:	1c3b      	adds	r3, r7, #0 124:	3330      	adds	r3, #48	; 0x30 126:	809a      	strh	r2, [r3, #4]      readBytes(MPU9250_ADDRESS, GYRO_XOUT_H, 6, &rawData[0]);       // Read the six raw data registers sequentially into data array 128:	1c3b      	adds	r3, r7, #0 12a:	3348      	adds	r3, #72	; 0x48 12c:	2068      	movs	r0, #104	; 0x68 12e:	2143      	movs	r1, #67	; 0x43 130:	2206      	movs	r2, #6 132:	f7ff fffe 	bl	0 <readBytes>			132: R_ARM_THM_CALL	readBytes    gAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value 136:	1c3b      	adds	r3, r7, #0 138:	3338      	adds	r3, #56	; 0x38 13a:	881b      	ldrh	r3, [r3, #0] 13c:	b29a      	uxth	r2, r3 13e:	1c3b      	adds	r3, r7, #0 140:	3348      	adds	r3, #72	; 0x48 142:	781b      	ldrb	r3, [r3, #0] 144:	021b      	lsls	r3, r3, #8 146:	b299      	uxth	r1, r3 148:	1c3b      	adds	r3, r7, #0 14a:	3348      	adds	r3, #72	; 0x48 14c:	785b      	ldrb	r3, [r3, #1] 14e:	430b      	orrs	r3, r1 150:	b29b      	uxth	r3, r3 152:	b29b      	uxth	r3, r3 154:	18d3      	adds	r3, r2, r3 156:	b29b      	uxth	r3, r3 158:	b29a      	uxth	r2, r3 15a:	1c3b      	adds	r3, r7, #0 15c:	3338      	adds	r3, #56	; 0x38 15e:	801a      	strh	r2, [r3, #0]    gAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;   160:	1c3b      	adds	r3, r7, #0 162:	3338      	adds	r3, #56	; 0x38 164:	885b      	ldrh	r3, [r3, #2] 166:	b29a      	uxth	r2, r3 168:	1c3b      	adds	r3, r7, #0 16a:	3348      	adds	r3, #72	; 0x48 16c:	789b      	ldrb	r3, [r3, #2] 16e:	021b      	lsls	r3, r3, #8 170:	b299      	uxth	r1, r3 172:	1c3b      	adds	r3, r7, #0 174:	3348      	adds	r3, #72	; 0x48 176:	78db      	ldrb	r3, [r3, #3] 178:	430b      	orrs	r3, r1 17a:	b29b      	uxth	r3, r3 17c:	b29b      	uxth	r3, r3 17e:	18d3      	adds	r3, r2, r3 180:	b29b      	uxth	r3, r3 182:	b29a      	uxth	r2, r3 184:	1c3b      	adds	r3, r7, #0 186:	3338      	adds	r3, #56	; 0x38 188:	805a      	strh	r2, [r3, #2]    gAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;  18a:	1c3b      	adds	r3, r7, #0 18c:	3338      	adds	r3, #56	; 0x38 18e:	889b      	ldrh	r3, [r3, #4] 190:	b29a      	uxth	r2, r3 192:	1c3b      	adds	r3, r7, #0 194:	3348      	adds	r3, #72	; 0x48 196:	791b      	ldrb	r3, [r3, #4] 198:	021b      	lsls	r3, r3, #8 19a:	b299      	uxth	r1, r3 19c:	1c3b      	adds	r3, r7, #0 19e:	3348      	adds	r3, #72	; 0x48 1a0:	795b      	ldrb	r3, [r3, #5] 1a2:	430b      	orrs	r3, r1 1a4:	b29b      	uxth	r3, r3 1a6:	b29b      	uxth	r3, r3 1a8:	18d3      	adds	r3, r2, r3 1aa:	b29b      	uxth	r3, r3 1ac:	b29a      	uxth	r2, r3 1ae:	1c3b      	adds	r3, r7, #0 1b0:	3338      	adds	r3, #56	; 0x38 1b2:	809a      	strh	r2, [r3, #4]  writeByte(MPU9250_ADDRESS, GYRO_CONFIG, 1<<FS);  // Set full scale range for the gyro to 250 dps  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG2, 0x02); // Set accelerometer rate to 1 kHz and bandwidth to 92 Hz  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 1<<FS); // Set full scale range for the accelerometer to 2 g  int ii;  for(  ii = 0; ii < 200; ii++) {  // get average current values of gyro and acclerometer 1b4:	6d7b      	ldr	r3, [r7, #84]	; 0x54 1b6:	3301      	adds	r3, #1 1b8:	657b      	str	r3, [r7, #84]	; 0x54 1ba:	6d7b      	ldr	r3, [r7, #84]	; 0x54 1bc:	2bc7      	cmp	r3, #199	; 0xc7 1be:	dc00      	bgt.n	1c2 <MPU9250SelfTest+0x1c2> 1c0:	e76c      	b.n	9c <MPU9250SelfTest+0x9c>    gAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value    gAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;      gAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;   }    for (ii =0; ii < 3; ii++) {  // Get average of 200 values and store as average current readings 1c2:	2300      	movs	r3, #0 1c4:	657b      	str	r3, [r7, #84]	; 0x54 1c6:	e024      	b.n	212 <MPU9250SelfTest+0x212>    aAvg[ii] /= 200; 1c8:	1c3b      	adds	r3, r7, #0 1ca:	3330      	adds	r3, #48	; 0x30 1cc:	6d7a      	ldr	r2, [r7, #84]	; 0x54 1ce:	0052      	lsls	r2, r2, #1 1d0:	5ad3      	ldrh	r3, [r2, r3] 1d2:	b21b      	sxth	r3, r3 1d4:	1c18      	adds	r0, r3, #0 1d6:	21c8      	movs	r1, #200	; 0xc8 1d8:	f7ff fffe 	bl	0 <__aeabi_idiv>			1d8: R_ARM_THM_CALL	__aeabi_idiv 1dc:	1c03      	adds	r3, r0, #0 1de:	b299      	uxth	r1, r3 1e0:	1c3b      	adds	r3, r7, #0 1e2:	3330      	adds	r3, #48	; 0x30 1e4:	6d7a      	ldr	r2, [r7, #84]	; 0x54 1e6:	0052      	lsls	r2, r2, #1 1e8:	52d1      	strh	r1, [r2, r3]    gAvg[ii] /= 200; 1ea:	1c3b      	adds	r3, r7, #0 1ec:	3338      	adds	r3, #56	; 0x38 1ee:	6d7a      	ldr	r2, [r7, #84]	; 0x54 1f0:	0052      	lsls	r2, r2, #1 1f2:	5ad3      	ldrh	r3, [r2, r3] 1f4:	b21b      	sxth	r3, r3 1f6:	1c18      	adds	r0, r3, #0 1f8:	21c8      	movs	r1, #200	; 0xc8 1fa:	f7ff fffe 	bl	0 <__aeabi_idiv>			1fa: R_ARM_THM_CALL	__aeabi_idiv 1fe:	1c03      	adds	r3, r0, #0 200:	b299      	uxth	r1, r3 202:	1c3b      	adds	r3, r7, #0 204:	3338      	adds	r3, #56	; 0x38 206:	6d7a      	ldr	r2, [r7, #84]	; 0x54 208:	0052      	lsls	r2, r2, #1 20a:	52d1      	strh	r1, [r2, r3]    gAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value    gAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;      gAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;   }    for (ii =0; ii < 3; ii++) {  // Get average of 200 values and store as average current readings 20c:	6d7b      	ldr	r3, [r7, #84]	; 0x54 20e:	3301      	adds	r3, #1 210:	657b      	str	r3, [r7, #84]	; 0x54 212:	6d7b      	ldr	r3, [r7, #84]	; 0x54 214:	2b02      	cmp	r3, #2 216:	ddd7      	ble.n	1c8 <MPU9250SelfTest+0x1c8>    aAvg[ii] /= 200;    gAvg[ii] /= 200;  }  // Configure the accelerometer for self-test  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 0xE0); // Enable self test on all three axes and set accelerometer range to +/- 2 g 218:	2068      	movs	r0, #104	; 0x68 21a:	211c      	movs	r1, #28 21c:	22e0      	movs	r2, #224	; 0xe0 21e:	f7ff fffe 	bl	0 <writeByte>			21e: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, GYRO_CONFIG,  0xE0); // Enable self test on all three axes and set gyro range to +/- 250 degrees/s 222:	2068      	movs	r0, #104	; 0x68 224:	211b      	movs	r1, #27 226:	22e0      	movs	r2, #224	; 0xe0 228:	f7ff fffe 	bl	0 <writeByte>			228: R_ARM_THM_CALL	writeByte  delay(25);  // Delay a while to let the device stabilize 22c:	2019      	movs	r0, #25 22e:	f7ff fffe 	bl	0 <MPU9250SelfTest>			22e: R_ARM_THM_CALL	delay  for(ii = 0; ii < 200; ii++) {  // get average self-test values of gyro and acclerometer 232:	2300      	movs	r3, #0 234:	657b      	str	r3, [r7, #84]	; 0x54 236:	e08e      	b.n	356 <MPU9250SelfTest+0x356>      readBytes(MPU9250_ADDRESS, ACCEL_XOUT_H, 6, &rawData[0]);  // Read the six raw data registers into data array 238:	1c3b      	adds	r3, r7, #0 23a:	3348      	adds	r3, #72	; 0x48 23c:	2068      	movs	r0, #104	; 0x68 23e:	213b      	movs	r1, #59	; 0x3b 240:	2206      	movs	r2, #6 242:	f7ff fffe 	bl	0 <readBytes>			242: R_ARM_THM_CALL	readBytes    aSTAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value 246:	1c3b      	adds	r3, r7, #0 248:	3328      	adds	r3, #40	; 0x28 24a:	881b      	ldrh	r3, [r3, #0] 24c:	b29a      	uxth	r2, r3 24e:	1c3b      	adds	r3, r7, #0 250:	3348      	adds	r3, #72	; 0x48 252:	781b      	ldrb	r3, [r3, #0] 254:	021b      	lsls	r3, r3, #8 256:	b299      	uxth	r1, r3 258:	1c3b      	adds	r3, r7, #0 25a:	3348      	adds	r3, #72	; 0x48 25c:	785b      	ldrb	r3, [r3, #1] 25e:	430b      	orrs	r3, r1 260:	b29b      	uxth	r3, r3 262:	b29b      	uxth	r3, r3 264:	18d3      	adds	r3, r2, r3 266:	b29b      	uxth	r3, r3 268:	b29a      	uxth	r2, r3 26a:	1c3b      	adds	r3, r7, #0 26c:	3328      	adds	r3, #40	; 0x28 26e:	801a      	strh	r2, [r3, #0]    aSTAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;   270:	1c3b      	adds	r3, r7, #0 272:	3328      	adds	r3, #40	; 0x28 274:	885b      	ldrh	r3, [r3, #2] 276:	b29a      	uxth	r2, r3 278:	1c3b      	adds	r3, r7, #0 27a:	3348      	adds	r3, #72	; 0x48 27c:	789b      	ldrb	r3, [r3, #2] 27e:	021b      	lsls	r3, r3, #8 280:	b299      	uxth	r1, r3 282:	1c3b      	adds	r3, r7, #0 284:	3348      	adds	r3, #72	; 0x48 286:	78db      	ldrb	r3, [r3, #3] 288:	430b      	orrs	r3, r1 28a:	b29b      	uxth	r3, r3 28c:	b29b      	uxth	r3, r3 28e:	18d3      	adds	r3, r2, r3 290:	b29b      	uxth	r3, r3 292:	b29a      	uxth	r2, r3 294:	1c3b      	adds	r3, r7, #0 296:	3328      	adds	r3, #40	; 0x28 298:	805a      	strh	r2, [r3, #2]    aSTAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;  29a:	1c3b      	adds	r3, r7, #0 29c:	3328      	adds	r3, #40	; 0x28 29e:	889b      	ldrh	r3, [r3, #4] 2a0:	b29a      	uxth	r2, r3 2a2:	1c3b      	adds	r3, r7, #0 2a4:	3348      	adds	r3, #72	; 0x48 2a6:	791b      	ldrb	r3, [r3, #4] 2a8:	021b      	lsls	r3, r3, #8 2aa:	b299      	uxth	r1, r3 2ac:	1c3b      	adds	r3, r7, #0 2ae:	3348      	adds	r3, #72	; 0x48 2b0:	795b      	ldrb	r3, [r3, #5] 2b2:	430b      	orrs	r3, r1 2b4:	b29b      	uxth	r3, r3 2b6:	b29b      	uxth	r3, r3 2b8:	18d3      	adds	r3, r2, r3 2ba:	b29b      	uxth	r3, r3 2bc:	b29a      	uxth	r2, r3 2be:	1c3b      	adds	r3, r7, #0 2c0:	3328      	adds	r3, #40	; 0x28 2c2:	809a      	strh	r2, [r3, #4]      readBytes(MPU9250_ADDRESS, GYRO_XOUT_H, 6, &rawData[0]);  // Read the six raw data registers sequentially into data array 2c4:	1c3b      	adds	r3, r7, #0 2c6:	3348      	adds	r3, #72	; 0x48 2c8:	2068      	movs	r0, #104	; 0x68 2ca:	2143      	movs	r1, #67	; 0x43 2cc:	2206      	movs	r2, #6 2ce:	f7ff fffe 	bl	0 <readBytes>			2ce: R_ARM_THM_CALL	readBytes    gSTAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value 2d2:	1c3b      	adds	r3, r7, #0 2d4:	3320      	adds	r3, #32 2d6:	881b      	ldrh	r3, [r3, #0] 2d8:	b29a      	uxth	r2, r3 2da:	1c3b      	adds	r3, r7, #0 2dc:	3348      	adds	r3, #72	; 0x48 2de:	781b      	ldrb	r3, [r3, #0] 2e0:	021b      	lsls	r3, r3, #8 2e2:	b299      	uxth	r1, r3 2e4:	1c3b      	adds	r3, r7, #0 2e6:	3348      	adds	r3, #72	; 0x48 2e8:	785b      	ldrb	r3, [r3, #1] 2ea:	430b      	orrs	r3, r1 2ec:	b29b      	uxth	r3, r3 2ee:	b29b      	uxth	r3, r3 2f0:	18d3      	adds	r3, r2, r3 2f2:	b29b      	uxth	r3, r3 2f4:	b29a      	uxth	r2, r3 2f6:	1c3b      	adds	r3, r7, #0 2f8:	3320      	adds	r3, #32 2fa:	801a      	strh	r2, [r3, #0]    gSTAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;   2fc:	1c3b      	adds	r3, r7, #0 2fe:	3320      	adds	r3, #32 300:	885b      	ldrh	r3, [r3, #2] 302:	b29a      	uxth	r2, r3 304:	1c3b      	adds	r3, r7, #0 306:	3348      	adds	r3, #72	; 0x48 308:	789b      	ldrb	r3, [r3, #2] 30a:	021b      	lsls	r3, r3, #8 30c:	b299      	uxth	r1, r3 30e:	1c3b      	adds	r3, r7, #0 310:	3348      	adds	r3, #72	; 0x48 312:	78db      	ldrb	r3, [r3, #3] 314:	430b      	orrs	r3, r1 316:	b29b      	uxth	r3, r3 318:	b29b      	uxth	r3, r3 31a:	18d3      	adds	r3, r2, r3 31c:	b29b      	uxth	r3, r3 31e:	b29a      	uxth	r2, r3 320:	1c3b      	adds	r3, r7, #0 322:	3320      	adds	r3, #32 324:	805a      	strh	r2, [r3, #2]    gSTAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;  326:	1c3b      	adds	r3, r7, #0 328:	3320      	adds	r3, #32 32a:	889b      	ldrh	r3, [r3, #4] 32c:	b29a      	uxth	r2, r3 32e:	1c3b      	adds	r3, r7, #0 330:	3348      	adds	r3, #72	; 0x48 332:	791b      	ldrb	r3, [r3, #4] 334:	021b      	lsls	r3, r3, #8 336:	b299      	uxth	r1, r3 338:	1c3b      	adds	r3, r7, #0 33a:	3348      	adds	r3, #72	; 0x48 33c:	795b      	ldrb	r3, [r3, #5] 33e:	430b      	orrs	r3, r1 340:	b29b      	uxth	r3, r3 342:	b29b      	uxth	r3, r3 344:	18d3      	adds	r3, r2, r3 346:	b29b      	uxth	r3, r3 348:	b29a      	uxth	r2, r3 34a:	1c3b      	adds	r3, r7, #0 34c:	3320      	adds	r3, #32 34e:	809a      	strh	r2, [r3, #4]// Configure the accelerometer for self-test  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 0xE0); // Enable self test on all three axes and set accelerometer range to +/- 2 g  writeByte(MPU9250_ADDRESS, GYRO_CONFIG,  0xE0); // Enable self test on all three axes and set gyro range to +/- 250 degrees/s  delay(25);  // Delay a while to let the device stabilize  for(ii = 0; ii < 200; ii++) {  // get average self-test values of gyro and acclerometer 350:	6d7b      	ldr	r3, [r7, #84]	; 0x54 352:	3301      	adds	r3, #1 354:	657b      	str	r3, [r7, #84]	; 0x54 356:	6d7b      	ldr	r3, [r7, #84]	; 0x54 358:	2bc7      	cmp	r3, #199	; 0xc7 35a:	dc00      	bgt.n	35e <MPU9250SelfTest+0x35e> 35c:	e76c      	b.n	238 <MPU9250SelfTest+0x238>    gSTAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value    gSTAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;      gSTAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;   }    for (ii =0; ii < 3; ii++) {  // Get average of 200 values and store as average self-test readings 35e:	2300      	movs	r3, #0 360:	657b      	str	r3, [r7, #84]	; 0x54 362:	e024      	b.n	3ae <MPU9250SelfTest+0x3ae>    aSTAvg[ii] /= 200; 364:	1c3b      	adds	r3, r7, #0 366:	3328      	adds	r3, #40	; 0x28 368:	6d7a      	ldr	r2, [r7, #84]	; 0x54 36a:	0052      	lsls	r2, r2, #1 36c:	5ad3      	ldrh	r3, [r2, r3] 36e:	b21b      	sxth	r3, r3 370:	1c18      	adds	r0, r3, #0 372:	21c8      	movs	r1, #200	; 0xc8 374:	f7ff fffe 	bl	0 <__aeabi_idiv>			374: R_ARM_THM_CALL	__aeabi_idiv 378:	1c03      	adds	r3, r0, #0 37a:	b299      	uxth	r1, r3 37c:	1c3b      	adds	r3, r7, #0 37e:	3328      	adds	r3, #40	; 0x28 380:	6d7a      	ldr	r2, [r7, #84]	; 0x54 382:	0052      	lsls	r2, r2, #1 384:	52d1      	strh	r1, [r2, r3]    gSTAvg[ii] /= 200; 386:	1c3b      	adds	r3, r7, #0 388:	3320      	adds	r3, #32 38a:	6d7a      	ldr	r2, [r7, #84]	; 0x54 38c:	0052      	lsls	r2, r2, #1 38e:	5ad3      	ldrh	r3, [r2, r3] 390:	b21b      	sxth	r3, r3 392:	1c18      	adds	r0, r3, #0 394:	21c8      	movs	r1, #200	; 0xc8 396:	f7ff fffe 	bl	0 <__aeabi_idiv>			396: R_ARM_THM_CALL	__aeabi_idiv 39a:	1c03      	adds	r3, r0, #0 39c:	b299      	uxth	r1, r3 39e:	1c3b      	adds	r3, r7, #0 3a0:	3320      	adds	r3, #32 3a2:	6d7a      	ldr	r2, [r7, #84]	; 0x54 3a4:	0052      	lsls	r2, r2, #1 3a6:	52d1      	strh	r1, [r2, r3]    gSTAvg[0] += (int16_t)(((int16_t)rawData[0] << 8) | rawData[1]) ;  // Turn the MSB and LSB into a signed 16-bit value    gSTAvg[1] += (int16_t)(((int16_t)rawData[2] << 8) | rawData[3]) ;      gSTAvg[2] += (int16_t)(((int16_t)rawData[4] << 8) | rawData[5]) ;   }    for (ii =0; ii < 3; ii++) {  // Get average of 200 values and store as average self-test readings 3a8:	6d7b      	ldr	r3, [r7, #84]	; 0x54 3aa:	3301      	adds	r3, #1 3ac:	657b      	str	r3, [r7, #84]	; 0x54 3ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54 3b0:	2b02      	cmp	r3, #2 3b2:	ddd7      	ble.n	364 <MPU9250SelfTest+0x364>    aSTAvg[ii] /= 200;    gSTAvg[ii] /= 200;  }       // Configure the gyro and accelerometer for normal operation  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 0x00);   3b4:	2068      	movs	r0, #104	; 0x68 3b6:	211c      	movs	r1, #28 3b8:	2200      	movs	r2, #0 3ba:	f7ff fffe 	bl	0 <writeByte>			3ba: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, GYRO_CONFIG,  0x00);   3be:	2068      	movs	r0, #104	; 0x68 3c0:	211b      	movs	r1, #27 3c2:	2200      	movs	r2, #0 3c4:	f7ff fffe 	bl	0 <writeByte>			3c4: R_ARM_THM_CALL	writeByte  delay(25);  // Delay a while to let the device stabilize 3c8:	2019      	movs	r0, #25 3ca:	f7ff fffe 	bl	0 <MPU9250SelfTest>			3ca: R_ARM_THM_CALL	delay     // Retrieve accelerometer and gyro factory Self-Test Code from USR_Reg  selfTest[0] = readByte(MPU9250_ADDRESS, SELF_TEST_X_ACCEL); // X-axis accel self-test results 3ce:	2068      	movs	r0, #104	; 0x68 3d0:	210d      	movs	r1, #13 3d2:	f7ff fffe 	bl	0 <readByte>			3d2: R_ARM_THM_CALL	readByte 3d6:	1c03      	adds	r3, r0, #0 3d8:	1c1a      	adds	r2, r3, #0 3da:	1c3b      	adds	r3, r7, #0 3dc:	3340      	adds	r3, #64	; 0x40 3de:	701a      	strb	r2, [r3, #0]  selfTest[1] = readByte(MPU9250_ADDRESS, SELF_TEST_Y_ACCEL); // Y-axis accel self-test results 3e0:	2068      	movs	r0, #104	; 0x68 3e2:	210e      	movs	r1, #14 3e4:	f7ff fffe 	bl	0 <readByte>			3e4: R_ARM_THM_CALL	readByte 3e8:	1c03      	adds	r3, r0, #0 3ea:	1c1a      	adds	r2, r3, #0 3ec:	1c3b      	adds	r3, r7, #0 3ee:	3340      	adds	r3, #64	; 0x40 3f0:	705a      	strb	r2, [r3, #1]  selfTest[2] = readByte(MPU9250_ADDRESS, SELF_TEST_Z_ACCEL); // Z-axis accel self-test results 3f2:	2068      	movs	r0, #104	; 0x68 3f4:	210f      	movs	r1, #15 3f6:	f7ff fffe 	bl	0 <readByte>			3f6: R_ARM_THM_CALL	readByte 3fa:	1c03      	adds	r3, r0, #0 3fc:	1c1a      	adds	r2, r3, #0 3fe:	1c3b      	adds	r3, r7, #0 400:	3340      	adds	r3, #64	; 0x40 402:	709a      	strb	r2, [r3, #2]  selfTest[3] = readByte(MPU9250_ADDRESS, SELF_TEST_X_GYRO);  // X-axis gyro self-test results 404:	2068      	movs	r0, #104	; 0x68 406:	2100      	movs	r1, #0 408:	f7ff fffe 	bl	0 <readByte>			408: R_ARM_THM_CALL	readByte 40c:	1c03      	adds	r3, r0, #0 40e:	1c1a      	adds	r2, r3, #0 410:	1c3b      	adds	r3, r7, #0 412:	3340      	adds	r3, #64	; 0x40 414:	70da      	strb	r2, [r3, #3]  selfTest[4] = readByte(MPU9250_ADDRESS, SELF_TEST_Y_GYRO);  // Y-axis gyro self-test results 416:	2068      	movs	r0, #104	; 0x68 418:	2101      	movs	r1, #1 41a:	f7ff fffe 	bl	0 <readByte>			41a: R_ARM_THM_CALL	readByte 41e:	1c03      	adds	r3, r0, #0 420:	1c1a      	adds	r2, r3, #0 422:	1c3b      	adds	r3, r7, #0 424:	3340      	adds	r3, #64	; 0x40 426:	711a      	strb	r2, [r3, #4]  selfTest[5] = readByte(MPU9250_ADDRESS, SELF_TEST_Z_GYRO);  // Z-axis gyro self-test results 428:	2068      	movs	r0, #104	; 0x68 42a:	2102      	movs	r1, #2 42c:	f7ff fffe 	bl	0 <readByte>			42c: R_ARM_THM_CALL	readByte 430:	1c03      	adds	r3, r0, #0 432:	1c1a      	adds	r2, r3, #0 434:	1c3b      	adds	r3, r7, #0 436:	3340      	adds	r3, #64	; 0x40 438:	715a      	strb	r2, [r3, #5]  // Retrieve factory self-test value from self-test code reads  factoryTrim[0] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)selfTest[0] - 1.0) )); // FT[Xa] factory trim calculation 43a:	1c3b      	adds	r3, r7, #0 43c:	334f      	adds	r3, #79	; 0x4f 43e:	781b      	ldrb	r3, [r3, #0] 440:	4abd      	ldr	r2, [pc, #756]	; (738 <MPU9250SelfTest+0x738>) 442:	1c11      	adds	r1, r2, #0 444:	4099      	lsls	r1, r3 446:	1c0b      	adds	r3, r1, #0 448:	1c18      	adds	r0, r3, #0 44a:	f7ff fffe 	bl	0 <__aeabi_i2f>			44a: R_ARM_THM_CALL	__aeabi_i2f 44e:	1c03      	adds	r3, r0, #0 450:	1c18      	adds	r0, r3, #0 452:	f7ff fffe 	bl	0 <__aeabi_f2d>			452: R_ARM_THM_CALL	__aeabi_f2d 456:	1c05      	adds	r5, r0, #0 458:	1c0e      	adds	r6, r1, #0 45a:	1c3b      	adds	r3, r7, #0 45c:	3340      	adds	r3, #64	; 0x40 45e:	781b      	ldrb	r3, [r3, #0] 460:	1c18      	adds	r0, r3, #0 462:	f7ff fffe 	bl	0 <__aeabi_ui2f>			462: R_ARM_THM_CALL	__aeabi_ui2f 466:	1c03      	adds	r3, r0, #0 468:	1c18      	adds	r0, r3, #0 46a:	f7ff fffe 	bl	0 <__aeabi_f2d>			46a: R_ARM_THM_CALL	__aeabi_f2d 46e:	1c03      	adds	r3, r0, #0 470:	1c0c      	adds	r4, r1, #0 472:	1c18      	adds	r0, r3, #0 474:	1c21      	adds	r1, r4, #0 476:	4bad      	ldr	r3, [pc, #692]	; (72c <MPU9250SelfTest+0x72c>) 478:	4aab      	ldr	r2, [pc, #684]	; (728 <MPU9250SelfTest+0x728>) 47a:	f7ff fffe 	bl	0 <__aeabi_dsub>			47a: R_ARM_THM_CALL	__aeabi_dsub 47e:	1c03      	adds	r3, r0, #0 480:	1c0c      	adds	r4, r1, #0 482:	49ab      	ldr	r1, [pc, #684]	; (730 <MPU9250SelfTest+0x730>) 484:	4aab      	ldr	r2, [pc, #684]	; (734 <MPU9250SelfTest+0x734>) 486:	1c08      	adds	r0, r1, #0 488:	1c11      	adds	r1, r2, #0 48a:	1c1a      	adds	r2, r3, #0 48c:	1c23      	adds	r3, r4, #0 48e:	f7ff fffe 	bl	0 <pow>			48e: R_ARM_THM_CALL	pow 492:	1c03      	adds	r3, r0, #0 494:	1c0c      	adds	r4, r1, #0 496:	1c28      	adds	r0, r5, #0 498:	1c31      	adds	r1, r6, #0 49a:	1c1a      	adds	r2, r3, #0 49c:	1c23      	adds	r3, r4, #0 49e:	f7ff fffe 	bl	0 <__aeabi_dmul>			49e: R_ARM_THM_CALL	__aeabi_dmul 4a2:	1c03      	adds	r3, r0, #0 4a4:	1c0c      	adds	r4, r1, #0 4a6:	1c18      	adds	r0, r3, #0 4a8:	1c21      	adds	r1, r4, #0 4aa:	f7ff fffe 	bl	0 <__aeabi_d2f>			4aa: R_ARM_THM_CALL	__aeabi_d2f 4ae:	1c02      	adds	r2, r0, #0 4b0:	1c3b      	adds	r3, r7, #0 4b2:	3308      	adds	r3, #8 4b4:	601a      	str	r2, [r3, #0]  factoryTrim[1] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)selfTest[1] - 1.0) )); // FT[Ya] factory trim calculation 4b6:	1c3b      	adds	r3, r7, #0 4b8:	334f      	adds	r3, #79	; 0x4f 4ba:	781b      	ldrb	r3, [r3, #0] 4bc:	4a9e      	ldr	r2, [pc, #632]	; (738 <MPU9250SelfTest+0x738>) 4be:	1c11      	adds	r1, r2, #0 4c0:	4099      	lsls	r1, r3 4c2:	1c0b      	adds	r3, r1, #0 4c4:	1c18      	adds	r0, r3, #0 4c6:	f7ff fffe 	bl	0 <__aeabi_i2f>			4c6: R_ARM_THM_CALL	__aeabi_i2f 4ca:	1c03      	adds	r3, r0, #0 4cc:	1c18      	adds	r0, r3, #0 4ce:	f7ff fffe 	bl	0 <__aeabi_f2d>			4ce: R_ARM_THM_CALL	__aeabi_f2d 4d2:	1c05      	adds	r5, r0, #0 4d4:	1c0e      	adds	r6, r1, #0 4d6:	1c3b      	adds	r3, r7, #0 4d8:	3340      	adds	r3, #64	; 0x40 4da:	785b      	ldrb	r3, [r3, #1] 4dc:	1c18      	adds	r0, r3, #0 4de:	f7ff fffe 	bl	0 <__aeabi_ui2f>			4de: R_ARM_THM_CALL	__aeabi_ui2f 4e2:	1c03      	adds	r3, r0, #0 4e4:	1c18      	adds	r0, r3, #0 4e6:	f7ff fffe 	bl	0 <__aeabi_f2d>			4e6: R_ARM_THM_CALL	__aeabi_f2d 4ea:	1c03      	adds	r3, r0, #0 4ec:	1c0c      	adds	r4, r1, #0 4ee:	1c18      	adds	r0, r3, #0 4f0:	1c21      	adds	r1, r4, #0 4f2:	4b8e      	ldr	r3, [pc, #568]	; (72c <MPU9250SelfTest+0x72c>) 4f4:	4a8c      	ldr	r2, [pc, #560]	; (728 <MPU9250SelfTest+0x728>) 4f6:	f7ff fffe 	bl	0 <__aeabi_dsub>			4f6: R_ARM_THM_CALL	__aeabi_dsub 4fa:	1c03      	adds	r3, r0, #0 4fc:	1c0c      	adds	r4, r1, #0 4fe:	498c      	ldr	r1, [pc, #560]	; (730 <MPU9250SelfTest+0x730>) 500:	4a8c      	ldr	r2, [pc, #560]	; (734 <MPU9250SelfTest+0x734>) 502:	1c08      	adds	r0, r1, #0 504:	1c11      	adds	r1, r2, #0 506:	1c1a      	adds	r2, r3, #0 508:	1c23      	adds	r3, r4, #0 50a:	f7ff fffe 	bl	0 <pow>			50a: R_ARM_THM_CALL	pow 50e:	1c03      	adds	r3, r0, #0 510:	1c0c      	adds	r4, r1, #0 512:	1c28      	adds	r0, r5, #0 514:	1c31      	adds	r1, r6, #0 516:	1c1a      	adds	r2, r3, #0 518:	1c23      	adds	r3, r4, #0 51a:	f7ff fffe 	bl	0 <__aeabi_dmul>			51a: R_ARM_THM_CALL	__aeabi_dmul 51e:	1c03      	adds	r3, r0, #0 520:	1c0c      	adds	r4, r1, #0 522:	1c18      	adds	r0, r3, #0 524:	1c21      	adds	r1, r4, #0 526:	f7ff fffe 	bl	0 <__aeabi_d2f>			526: R_ARM_THM_CALL	__aeabi_d2f 52a:	1c02      	adds	r2, r0, #0 52c:	1c3b      	adds	r3, r7, #0 52e:	3308      	adds	r3, #8 530:	605a      	str	r2, [r3, #4]  factoryTrim[2] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)selfTest[2] - 1.0) )); // FT[Za] factory trim calculation 532:	1c3b      	adds	r3, r7, #0 534:	334f      	adds	r3, #79	; 0x4f 536:	781b      	ldrb	r3, [r3, #0] 538:	4a7f      	ldr	r2, [pc, #508]	; (738 <MPU9250SelfTest+0x738>) 53a:	1c11      	adds	r1, r2, #0 53c:	4099      	lsls	r1, r3 53e:	1c0b      	adds	r3, r1, #0 540:	1c18      	adds	r0, r3, #0 542:	f7ff fffe 	bl	0 <__aeabi_i2f>			542: R_ARM_THM_CALL	__aeabi_i2f 546:	1c03      	adds	r3, r0, #0 548:	1c18      	adds	r0, r3, #0 54a:	f7ff fffe 	bl	0 <__aeabi_f2d>			54a: R_ARM_THM_CALL	__aeabi_f2d 54e:	1c05      	adds	r5, r0, #0 550:	1c0e      	adds	r6, r1, #0 552:	1c3b      	adds	r3, r7, #0 554:	3340      	adds	r3, #64	; 0x40 556:	789b      	ldrb	r3, [r3, #2] 558:	1c18      	adds	r0, r3, #0 55a:	f7ff fffe 	bl	0 <__aeabi_ui2f>			55a: R_ARM_THM_CALL	__aeabi_ui2f 55e:	1c03      	adds	r3, r0, #0 560:	1c18      	adds	r0, r3, #0 562:	f7ff fffe 	bl	0 <__aeabi_f2d>			562: R_ARM_THM_CALL	__aeabi_f2d 566:	1c03      	adds	r3, r0, #0 568:	1c0c      	adds	r4, r1, #0 56a:	1c18      	adds	r0, r3, #0 56c:	1c21      	adds	r1, r4, #0 56e:	4b6f      	ldr	r3, [pc, #444]	; (72c <MPU9250SelfTest+0x72c>) 570:	4a6d      	ldr	r2, [pc, #436]	; (728 <MPU9250SelfTest+0x728>) 572:	f7ff fffe 	bl	0 <__aeabi_dsub>			572: R_ARM_THM_CALL	__aeabi_dsub 576:	1c03      	adds	r3, r0, #0 578:	1c0c      	adds	r4, r1, #0 57a:	496d      	ldr	r1, [pc, #436]	; (730 <MPU9250SelfTest+0x730>) 57c:	4a6d      	ldr	r2, [pc, #436]	; (734 <MPU9250SelfTest+0x734>) 57e:	1c08      	adds	r0, r1, #0 580:	1c11      	adds	r1, r2, #0 582:	1c1a      	adds	r2, r3, #0 584:	1c23      	adds	r3, r4, #0 586:	f7ff fffe 	bl	0 <pow>			586: R_ARM_THM_CALL	pow 58a:	1c03      	adds	r3, r0, #0 58c:	1c0c      	adds	r4, r1, #0 58e:	1c28      	adds	r0, r5, #0 590:	1c31      	adds	r1, r6, #0 592:	1c1a      	adds	r2, r3, #0 594:	1c23      	adds	r3, r4, #0 596:	f7ff fffe 	bl	0 <__aeabi_dmul>			596: R_ARM_THM_CALL	__aeabi_dmul 59a:	1c03      	adds	r3, r0, #0 59c:	1c0c      	adds	r4, r1, #0 59e:	1c18      	adds	r0, r3, #0 5a0:	1c21      	adds	r1, r4, #0 5a2:	f7ff fffe 	bl	0 <__aeabi_d2f>			5a2: R_ARM_THM_CALL	__aeabi_d2f 5a6:	1c02      	adds	r2, r0, #0 5a8:	1c3b      	adds	r3, r7, #0 5aa:	3308      	adds	r3, #8 5ac:	609a      	str	r2, [r3, #8]  factoryTrim[3] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)selfTest[3] - 1.0) )); // FT[Xg] factory trim calculation 5ae:	1c3b      	adds	r3, r7, #0 5b0:	334f      	adds	r3, #79	; 0x4f 5b2:	781b      	ldrb	r3, [r3, #0] 5b4:	4a60      	ldr	r2, [pc, #384]	; (738 <MPU9250SelfTest+0x738>) 5b6:	1c11      	adds	r1, r2, #0 5b8:	4099      	lsls	r1, r3 5ba:	1c0b      	adds	r3, r1, #0 5bc:	1c18      	adds	r0, r3, #0 5be:	f7ff fffe 	bl	0 <__aeabi_i2f>			5be: R_ARM_THM_CALL	__aeabi_i2f 5c2:	1c03      	adds	r3, r0, #0 5c4:	1c18      	adds	r0, r3, #0 5c6:	f7ff fffe 	bl	0 <__aeabi_f2d>			5c6: R_ARM_THM_CALL	__aeabi_f2d 5ca:	1c05      	adds	r5, r0, #0 5cc:	1c0e      	adds	r6, r1, #0 5ce:	1c3b      	adds	r3, r7, #0 5d0:	3340      	adds	r3, #64	; 0x40 5d2:	78db      	ldrb	r3, [r3, #3] 5d4:	1c18      	adds	r0, r3, #0 5d6:	f7ff fffe 	bl	0 <__aeabi_ui2f>			5d6: R_ARM_THM_CALL	__aeabi_ui2f 5da:	1c03      	adds	r3, r0, #0 5dc:	1c18      	adds	r0, r3, #0 5de:	f7ff fffe 	bl	0 <__aeabi_f2d>			5de: R_ARM_THM_CALL	__aeabi_f2d 5e2:	1c03      	adds	r3, r0, #0 5e4:	1c0c      	adds	r4, r1, #0 5e6:	1c18      	adds	r0, r3, #0 5e8:	1c21      	adds	r1, r4, #0 5ea:	4b50      	ldr	r3, [pc, #320]	; (72c <MPU9250SelfTest+0x72c>) 5ec:	4a4e      	ldr	r2, [pc, #312]	; (728 <MPU9250SelfTest+0x728>) 5ee:	f7ff fffe 	bl	0 <__aeabi_dsub>			5ee: R_ARM_THM_CALL	__aeabi_dsub 5f2:	1c03      	adds	r3, r0, #0 5f4:	1c0c      	adds	r4, r1, #0 5f6:	494e      	ldr	r1, [pc, #312]	; (730 <MPU9250SelfTest+0x730>) 5f8:	4a4e      	ldr	r2, [pc, #312]	; (734 <MPU9250SelfTest+0x734>) 5fa:	1c08      	adds	r0, r1, #0 5fc:	1c11      	adds	r1, r2, #0 5fe:	1c1a      	adds	r2, r3, #0 600:	1c23      	adds	r3, r4, #0 602:	f7ff fffe 	bl	0 <pow>			602: R_ARM_THM_CALL	pow 606:	1c03      	adds	r3, r0, #0 608:	1c0c      	adds	r4, r1, #0 60a:	1c28      	adds	r0, r5, #0 60c:	1c31      	adds	r1, r6, #0 60e:	1c1a      	adds	r2, r3, #0 610:	1c23      	adds	r3, r4, #0 612:	f7ff fffe 	bl	0 <__aeabi_dmul>			612: R_ARM_THM_CALL	__aeabi_dmul 616:	1c03      	adds	r3, r0, #0 618:	1c0c      	adds	r4, r1, #0 61a:	1c18      	adds	r0, r3, #0 61c:	1c21      	adds	r1, r4, #0 61e:	f7ff fffe 	bl	0 <__aeabi_d2f>			61e: R_ARM_THM_CALL	__aeabi_d2f 622:	1c02      	adds	r2, r0, #0 624:	1c3b      	adds	r3, r7, #0 626:	3308      	adds	r3, #8 628:	60da      	str	r2, [r3, #12]  factoryTrim[4] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)selfTest[4] - 1.0) )); // FT[Yg] factory trim calculation 62a:	1c3b      	adds	r3, r7, #0 62c:	334f      	adds	r3, #79	; 0x4f 62e:	781b      	ldrb	r3, [r3, #0] 630:	4a41      	ldr	r2, [pc, #260]	; (738 <MPU9250SelfTest+0x738>) 632:	1c11      	adds	r1, r2, #0 634:	4099      	lsls	r1, r3 636:	1c0b      	adds	r3, r1, #0 638:	1c18      	adds	r0, r3, #0 63a:	f7ff fffe 	bl	0 <__aeabi_i2f>			63a: R_ARM_THM_CALL	__aeabi_i2f 63e:	1c03      	adds	r3, r0, #0 640:	1c18      	adds	r0, r3, #0 642:	f7ff fffe 	bl	0 <__aeabi_f2d>			642: R_ARM_THM_CALL	__aeabi_f2d 646:	1c05      	adds	r5, r0, #0 648:	1c0e      	adds	r6, r1, #0 64a:	1c3b      	adds	r3, r7, #0 64c:	3340      	adds	r3, #64	; 0x40 64e:	791b      	ldrb	r3, [r3, #4] 650:	1c18      	adds	r0, r3, #0 652:	f7ff fffe 	bl	0 <__aeabi_ui2f>			652: R_ARM_THM_CALL	__aeabi_ui2f 656:	1c03      	adds	r3, r0, #0 658:	1c18      	adds	r0, r3, #0 65a:	f7ff fffe 	bl	0 <__aeabi_f2d>			65a: R_ARM_THM_CALL	__aeabi_f2d 65e:	1c03      	adds	r3, r0, #0 660:	1c0c      	adds	r4, r1, #0 662:	1c18      	adds	r0, r3, #0 664:	1c21      	adds	r1, r4, #0 666:	4b31      	ldr	r3, [pc, #196]	; (72c <MPU9250SelfTest+0x72c>) 668:	4a2f      	ldr	r2, [pc, #188]	; (728 <MPU9250SelfTest+0x728>) 66a:	f7ff fffe 	bl	0 <__aeabi_dsub>			66a: R_ARM_THM_CALL	__aeabi_dsub 66e:	1c03      	adds	r3, r0, #0 670:	1c0c      	adds	r4, r1, #0 672:	492f      	ldr	r1, [pc, #188]	; (730 <MPU9250SelfTest+0x730>) 674:	4a2f      	ldr	r2, [pc, #188]	; (734 <MPU9250SelfTest+0x734>) 676:	1c08      	adds	r0, r1, #0 678:	1c11      	adds	r1, r2, #0 67a:	1c1a      	adds	r2, r3, #0 67c:	1c23      	adds	r3, r4, #0 67e:	f7ff fffe 	bl	0 <pow>			67e: R_ARM_THM_CALL	pow 682:	1c03      	adds	r3, r0, #0 684:	1c0c      	adds	r4, r1, #0 686:	1c28      	adds	r0, r5, #0 688:	1c31      	adds	r1, r6, #0 68a:	1c1a      	adds	r2, r3, #0 68c:	1c23      	adds	r3, r4, #0 68e:	f7ff fffe 	bl	0 <__aeabi_dmul>			68e: R_ARM_THM_CALL	__aeabi_dmul 692:	1c03      	adds	r3, r0, #0 694:	1c0c      	adds	r4, r1, #0 696:	1c18      	adds	r0, r3, #0 698:	1c21      	adds	r1, r4, #0 69a:	f7ff fffe 	bl	0 <__aeabi_d2f>			69a: R_ARM_THM_CALL	__aeabi_d2f 69e:	1c02      	adds	r2, r0, #0 6a0:	1c3b      	adds	r3, r7, #0 6a2:	3308      	adds	r3, #8 6a4:	611a      	str	r2, [r3, #16]  factoryTrim[5] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)selfTest[5] - 1.0) )); // FT[Zg] factory trim calculation 6a6:	1c3b      	adds	r3, r7, #0 6a8:	334f      	adds	r3, #79	; 0x4f 6aa:	781b      	ldrb	r3, [r3, #0] 6ac:	4a22      	ldr	r2, [pc, #136]	; (738 <MPU9250SelfTest+0x738>) 6ae:	1c11      	adds	r1, r2, #0 6b0:	4099      	lsls	r1, r3 6b2:	1c0b      	adds	r3, r1, #0 6b4:	1c18      	adds	r0, r3, #0 6b6:	f7ff fffe 	bl	0 <__aeabi_i2f>			6b6: R_ARM_THM_CALL	__aeabi_i2f 6ba:	1c03      	adds	r3, r0, #0 6bc:	1c18      	adds	r0, r3, #0 6be:	f7ff fffe 	bl	0 <__aeabi_f2d>			6be: R_ARM_THM_CALL	__aeabi_f2d 6c2:	1c05      	adds	r5, r0, #0 6c4:	1c0e      	adds	r6, r1, #0 6c6:	1c3b      	adds	r3, r7, #0 6c8:	3340      	adds	r3, #64	; 0x40 6ca:	795b      	ldrb	r3, [r3, #5] 6cc:	1c18      	adds	r0, r3, #0 6ce:	f7ff fffe 	bl	0 <__aeabi_ui2f>			6ce: R_ARM_THM_CALL	__aeabi_ui2f 6d2:	1c03      	adds	r3, r0, #0 6d4:	1c18      	adds	r0, r3, #0 6d6:	f7ff fffe 	bl	0 <__aeabi_f2d>			6d6: R_ARM_THM_CALL	__aeabi_f2d 6da:	1c03      	adds	r3, r0, #0 6dc:	1c0c      	adds	r4, r1, #0 6de:	1c18      	adds	r0, r3, #0 6e0:	1c21      	adds	r1, r4, #0 6e2:	4b12      	ldr	r3, [pc, #72]	; (72c <MPU9250SelfTest+0x72c>) 6e4:	4a10      	ldr	r2, [pc, #64]	; (728 <MPU9250SelfTest+0x728>) 6e6:	f7ff fffe 	bl	0 <__aeabi_dsub>			6e6: R_ARM_THM_CALL	__aeabi_dsub 6ea:	1c03      	adds	r3, r0, #0 6ec:	1c0c      	adds	r4, r1, #0 6ee:	4910      	ldr	r1, [pc, #64]	; (730 <MPU9250SelfTest+0x730>) 6f0:	4a10      	ldr	r2, [pc, #64]	; (734 <MPU9250SelfTest+0x734>) 6f2:	1c08      	adds	r0, r1, #0 6f4:	1c11      	adds	r1, r2, #0 6f6:	1c1a      	adds	r2, r3, #0 6f8:	1c23      	adds	r3, r4, #0 6fa:	f7ff fffe 	bl	0 <pow>			6fa: R_ARM_THM_CALL	pow 6fe:	1c03      	adds	r3, r0, #0 700:	1c0c      	adds	r4, r1, #0 702:	1c28      	adds	r0, r5, #0 704:	1c31      	adds	r1, r6, #0 706:	1c1a      	adds	r2, r3, #0 708:	1c23      	adds	r3, r4, #0 70a:	f7ff fffe 	bl	0 <__aeabi_dmul>			70a: R_ARM_THM_CALL	__aeabi_dmul 70e:	1c03      	adds	r3, r0, #0 710:	1c0c      	adds	r4, r1, #0 712:	1c18      	adds	r0, r3, #0 714:	1c21      	adds	r1, r4, #0 716:	f7ff fffe 	bl	0 <__aeabi_d2f>			716: R_ARM_THM_CALL	__aeabi_d2f 71a:	1c02      	adds	r2, r0, #0 71c:	1c3b      	adds	r3, r7, #0 71e:	3308      	adds	r3, #8 720:	615a      	str	r2, [r3, #20]  // Report results as a ratio of (STR - FT)/FT; the change from Factory Trim of the Self-Test Response // To get percent, must multiply by 100  int i;  for (i = 0; i < 3; i++) { 722:	2300      	movs	r3, #0 724:	653b      	str	r3, [r7, #80]	; 0x50 726:	e08a      	b.n	83e <MPU9250SelfTest+0x83e> 728:	00000000 	.word	0x00000000 72c:	3ff00000 	.word	0x3ff00000 730:	c28f5c29 	.word	0xc28f5c29 734:	3ff028f5 	.word	0x3ff028f5 738:	00000a3c 	.word	0x00000a3c    destination[i]   = 100.0*((float)(aSTAvg[i] - aAvg[i]))/factoryTrim[i];   // Report percent differences 73c:	6d3b      	ldr	r3, [r7, #80]	; 0x50 73e:	009b      	lsls	r3, r3, #2 740:	687a      	ldr	r2, [r7, #4] 742:	18d2      	adds	r2, r2, r3 744:	4690      	mov	r8, r2 746:	1c3b      	adds	r3, r7, #0 748:	3328      	adds	r3, #40	; 0x28 74a:	6d3a      	ldr	r2, [r7, #80]	; 0x50 74c:	0052      	lsls	r2, r2, #1 74e:	5ad3      	ldrh	r3, [r2, r3] 750:	b21a      	sxth	r2, r3 752:	1c3b      	adds	r3, r7, #0 754:	3330      	adds	r3, #48	; 0x30 756:	6d39      	ldr	r1, [r7, #80]	; 0x50 758:	0049      	lsls	r1, r1, #1 75a:	5acb      	ldrh	r3, [r1, r3] 75c:	b21b      	sxth	r3, r3 75e:	1ad3      	subs	r3, r2, r3 760:	1c18      	adds	r0, r3, #0 762:	f7ff fffe 	bl	0 <__aeabi_i2f>			762: R_ARM_THM_CALL	__aeabi_i2f 766:	1c03      	adds	r3, r0, #0 768:	1c18      	adds	r0, r3, #0 76a:	f7ff fffe 	bl	0 <__aeabi_f2d>			76a: R_ARM_THM_CALL	__aeabi_f2d 76e:	1c03      	adds	r3, r0, #0 770:	1c0c      	adds	r4, r1, #0 772:	1c18      	adds	r0, r3, #0 774:	1c21      	adds	r1, r4, #0 776:	4b37      	ldr	r3, [pc, #220]	; (854 <MPU9250SelfTest+0x854>) 778:	4a35      	ldr	r2, [pc, #212]	; (850 <MPU9250SelfTest+0x850>) 77a:	f7ff fffe 	bl	0 <__aeabi_dmul>			77a: R_ARM_THM_CALL	__aeabi_dmul 77e:	1c03      	adds	r3, r0, #0 780:	1c0c      	adds	r4, r1, #0 782:	1c1d      	adds	r5, r3, #0 784:	1c26      	adds	r6, r4, #0 786:	1c3b      	adds	r3, r7, #0 788:	3308      	adds	r3, #8 78a:	6d3a      	ldr	r2, [r7, #80]	; 0x50 78c:	0092      	lsls	r2, r2, #2 78e:	58d3      	ldr	r3, [r2, r3] 790:	1c18      	adds	r0, r3, #0 792:	f7ff fffe 	bl	0 <__aeabi_f2d>			792: R_ARM_THM_CALL	__aeabi_f2d 796:	1c03      	adds	r3, r0, #0 798:	1c0c      	adds	r4, r1, #0 79a:	1c28      	adds	r0, r5, #0 79c:	1c31      	adds	r1, r6, #0 79e:	1c1a      	adds	r2, r3, #0 7a0:	1c23      	adds	r3, r4, #0 7a2:	f7ff fffe 	bl	0 <__aeabi_ddiv>			7a2: R_ARM_THM_CALL	__aeabi_ddiv 7a6:	1c03      	adds	r3, r0, #0 7a8:	1c0c      	adds	r4, r1, #0 7aa:	1c18      	adds	r0, r3, #0 7ac:	1c21      	adds	r1, r4, #0 7ae:	f7ff fffe 	bl	0 <__aeabi_d2f>			7ae: R_ARM_THM_CALL	__aeabi_d2f 7b2:	1c03      	adds	r3, r0, #0 7b4:	4642      	mov	r2, r8 7b6:	6013      	str	r3, [r2, #0]    destination[i+3] = 100.0*((float)(gSTAvg[i] - gAvg[i]))/factoryTrim[i+3]; // Report percent differences 7b8:	6d3b      	ldr	r3, [r7, #80]	; 0x50 7ba:	3303      	adds	r3, #3 7bc:	009b      	lsls	r3, r3, #2 7be:	687a      	ldr	r2, [r7, #4] 7c0:	18d2      	adds	r2, r2, r3 7c2:	4690      	mov	r8, r2 7c4:	1c3b      	adds	r3, r7, #0 7c6:	3320      	adds	r3, #32 7c8:	6d3a      	ldr	r2, [r7, #80]	; 0x50 7ca:	0052      	lsls	r2, r2, #1 7cc:	5ad3      	ldrh	r3, [r2, r3] 7ce:	b21a      	sxth	r2, r3 7d0:	1c3b      	adds	r3, r7, #0 7d2:	3338      	adds	r3, #56	; 0x38 7d4:	6d39      	ldr	r1, [r7, #80]	; 0x50 7d6:	0049      	lsls	r1, r1, #1 7d8:	5acb      	ldrh	r3, [r1, r3] 7da:	b21b      	sxth	r3, r3 7dc:	1ad3      	subs	r3, r2, r3 7de:	1c18      	adds	r0, r3, #0 7e0:	f7ff fffe 	bl	0 <__aeabi_i2f>			7e0: R_ARM_THM_CALL	__aeabi_i2f 7e4:	1c03      	adds	r3, r0, #0 7e6:	1c18      	adds	r0, r3, #0 7e8:	f7ff fffe 	bl	0 <__aeabi_f2d>			7e8: R_ARM_THM_CALL	__aeabi_f2d 7ec:	1c03      	adds	r3, r0, #0 7ee:	1c0c      	adds	r4, r1, #0 7f0:	1c18      	adds	r0, r3, #0 7f2:	1c21      	adds	r1, r4, #0 7f4:	4b17      	ldr	r3, [pc, #92]	; (854 <MPU9250SelfTest+0x854>) 7f6:	4a16      	ldr	r2, [pc, #88]	; (850 <MPU9250SelfTest+0x850>) 7f8:	f7ff fffe 	bl	0 <__aeabi_dmul>			7f8: R_ARM_THM_CALL	__aeabi_dmul 7fc:	1c03      	adds	r3, r0, #0 7fe:	1c0c      	adds	r4, r1, #0 800:	1c1d      	adds	r5, r3, #0 802:	1c26      	adds	r6, r4, #0 804:	6d3b      	ldr	r3, [r7, #80]	; 0x50 806:	1cda      	adds	r2, r3, #3 808:	1c3b      	adds	r3, r7, #0 80a:	3308      	adds	r3, #8 80c:	0092      	lsls	r2, r2, #2 80e:	58d3      	ldr	r3, [r2, r3] 810:	1c18      	adds	r0, r3, #0 812:	f7ff fffe 	bl	0 <__aeabi_f2d>			812: R_ARM_THM_CALL	__aeabi_f2d 816:	1c03      	adds	r3, r0, #0 818:	1c0c      	adds	r4, r1, #0 81a:	1c28      	adds	r0, r5, #0 81c:	1c31      	adds	r1, r6, #0 81e:	1c1a      	adds	r2, r3, #0 820:	1c23      	adds	r3, r4, #0 822:	f7ff fffe 	bl	0 <__aeabi_ddiv>			822: R_ARM_THM_CALL	__aeabi_ddiv 826:	1c03      	adds	r3, r0, #0 828:	1c0c      	adds	r4, r1, #0 82a:	1c18      	adds	r0, r3, #0 82c:	1c21      	adds	r1, r4, #0 82e:	f7ff fffe 	bl	0 <__aeabi_d2f>			82e: R_ARM_THM_CALL	__aeabi_d2f 832:	1c03      	adds	r3, r0, #0 834:	4641      	mov	r1, r8 836:	600b      	str	r3, [r1, #0]  factoryTrim[5] = (float)(2620/1<<FS)*(pow( 1.01 , ((float)selfTest[5] - 1.0) )); // FT[Zg] factory trim calculation  // Report results as a ratio of (STR - FT)/FT; the change from Factory Trim of the Self-Test Response // To get percent, must multiply by 100  int i;  for (i = 0; i < 3; i++) { 838:	6d3b      	ldr	r3, [r7, #80]	; 0x50 83a:	3301      	adds	r3, #1 83c:	653b      	str	r3, [r7, #80]	; 0x50 83e:	6d3b      	ldr	r3, [r7, #80]	; 0x50 840:	2b02      	cmp	r3, #2 842:	dc00      	bgt.n	846 <MPU9250SelfTest+0x846> 844:	e77a      	b.n	73c <MPU9250SelfTest+0x73c>    destination[i]   = 100.0*((float)(aSTAvg[i] - aAvg[i]))/factoryTrim[i];   // Report percent differences    destination[i+3] = 100.0*((float)(gSTAvg[i] - gAvg[i]))/factoryTrim[i+3]; // Report percent differences  }} 846:	46bd      	mov	sp, r7 848:	b016      	add	sp, #88	; 0x58 84a:	bc04      	pop	{r2} 84c:	4690      	mov	r8, r2 84e:	bdf0      	pop	{r4, r5, r6, r7, pc} 850:	00000000 	.word	0x00000000 854:	40590000 	.word	0x40590000Disassembly of section .text.magcalMPU9250:00000000 <magcalMPU9250>:// Function which accumulates gyro and accelerometer data after device// initialization. It calculates the average of the at-rest readings and then// loads the resulting offsets into accelerometer and gyro bias registers.void magcalMPU9250(float * dest1, float * dest2){   0:	b093b590 	.word	0xb093b590   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]   8:	6039      	str	r1, [r7, #0]	uint16_t ii = 0, sample_count = 0;   a:	1c3b      	adds	r3, r7, #0   c:	3346      	adds	r3, #70	; 0x46   e:	2200      	movs	r2, #0  10:	801a      	strh	r2, [r3, #0]  12:	1c3b      	adds	r3, r7, #0  14:	3344      	adds	r3, #68	; 0x44  16:	2200      	movs	r2, #0  18:	801a      	strh	r2, [r3, #0]	  int32_t mag_bias[3] = {0, 0, 0}, mag_scale[3] = {0, 0, 0};  1a:	1c3b      	adds	r3, r7, #0  1c:	3330      	adds	r3, #48	; 0x30  1e:	2200      	movs	r2, #0  20:	601a      	str	r2, [r3, #0]  22:	1c3b      	adds	r3, r7, #0  24:	3330      	adds	r3, #48	; 0x30  26:	2200      	movs	r2, #0  28:	605a      	str	r2, [r3, #4]  2a:	1c3b      	adds	r3, r7, #0  2c:	3330      	adds	r3, #48	; 0x30  2e:	2200      	movs	r2, #0  30:	609a      	str	r2, [r3, #8]  32:	1c3b      	adds	r3, r7, #0  34:	3324      	adds	r3, #36	; 0x24  36:	2200      	movs	r2, #0  38:	601a      	str	r2, [r3, #0]  3a:	1c3b      	adds	r3, r7, #0  3c:	3324      	adds	r3, #36	; 0x24  3e:	2200      	movs	r2, #0  40:	605a      	str	r2, [r3, #4]  42:	1c3b      	adds	r3, r7, #0  44:	3324      	adds	r3, #36	; 0x24  46:	2200      	movs	r2, #0  48:	609a      	str	r2, [r3, #8]	  int16_t mag_max[3] = {-32767, -32767, -32767}, mag_min[3] = {32767, 32767, 32767}, mag_temp[3] = {0, 0, 0};  4a:	1c3a      	adds	r2, r7, #0  4c:	321c      	adds	r2, #28  4e:	4bc3      	ldr	r3, [pc, #780]	; (35c <magcalMPU9250+0x35c>)  50:	1c11      	adds	r1, r2, #0  52:	1c1a      	adds	r2, r3, #0  54:	2306      	movs	r3, #6  56:	1c08      	adds	r0, r1, #0  58:	1c11      	adds	r1, r2, #0  5a:	1c1a      	adds	r2, r3, #0  5c:	f7ff fffe 	bl	0 <memcpy>			5c: R_ARM_THM_CALL	memcpy  60:	1c3a      	adds	r2, r7, #0  62:	3214      	adds	r2, #20  64:	4bbe      	ldr	r3, [pc, #760]	; (360 <magcalMPU9250+0x360>)  66:	1c11      	adds	r1, r2, #0  68:	1c1a      	adds	r2, r3, #0  6a:	2306      	movs	r3, #6  6c:	1c08      	adds	r0, r1, #0  6e:	1c11      	adds	r1, r2, #0  70:	1c1a      	adds	r2, r3, #0  72:	f7ff fffe 	bl	0 <memcpy>			72: R_ARM_THM_CALL	memcpy  76:	1c3b      	adds	r3, r7, #0  78:	330c      	adds	r3, #12  7a:	2200      	movs	r2, #0  7c:	801a      	strh	r2, [r3, #0]  7e:	1c3b      	adds	r3, r7, #0  80:	330c      	adds	r3, #12  82:	2200      	movs	r2, #0  84:	805a      	strh	r2, [r3, #2]  86:	1c3b      	adds	r3, r7, #0  88:	330c      	adds	r3, #12  8a:	2200      	movs	r2, #0  8c:	809a      	strh	r2, [r3, #4]	  //Serial.println("Magnometer Calibration: Wave device in a figure eight until done!");	  //delay(4000);	  	// shoot for ~fifteen seconds of mag data	    if(mpu9250.Mmode == 0x02) sample_count = 128;  // at 8 Hz ODR, new mag data is available every 125 ms  8e:	4bb5      	ldr	r3, [pc, #724]	; (364 <magcalMPU9250+0x364>)  90:	78db      	ldrb	r3, [r3, #3]  92:	2b02      	cmp	r3, #2  94:	d103      	bne.n	9e <magcalMPU9250+0x9e>  96:	1c3b      	adds	r3, r7, #0  98:	3344      	adds	r3, #68	; 0x44  9a:	2280      	movs	r2, #128	; 0x80  9c:	801a      	strh	r2, [r3, #0]	    if(mpu9250.Mmode == 0x06) sample_count = 1500;  // at 100 Hz ODR, new mag data is available every 10 ms  9e:	4bb1      	ldr	r3, [pc, #708]	; (364 <magcalMPU9250+0x364>)  a0:	78db      	ldrb	r3, [r3, #3]  a2:	2b06      	cmp	r3, #6  a4:	d103      	bne.n	ae <magcalMPU9250+0xae>  a6:	1c3b      	adds	r3, r7, #0  a8:	3344      	adds	r3, #68	; 0x44  aa:	4aaf      	ldr	r2, [pc, #700]	; (368 <magcalMPU9250+0x368>)  ac:	801a      	strh	r2, [r3, #0]	    for(ii = 0; ii < sample_count; ii++) {  ae:	1c3b      	adds	r3, r7, #0  b0:	3346      	adds	r3, #70	; 0x46  b2:	2200      	movs	r2, #0  b4:	801a      	strh	r2, [r3, #0]  b6:	e052      	b.n	15e <magcalMPU9250+0x15e>	    readMagData(mag_temp);  // Read the mag data  b8:	1c3b      	adds	r3, r7, #0  ba:	330c      	adds	r3, #12  bc:	1c18      	adds	r0, r3, #0  be:	f7ff fffe 	bl	0 <magcalMPU9250>			be: R_ARM_THM_CALL	readMagData	    int jj;	    for (jj = 0; jj < 3; jj++) {  c2:	2300      	movs	r3, #0  c4:	643b      	str	r3, [r7, #64]	; 0x40  c6:	e032      	b.n	12e <magcalMPU9250+0x12e>	      if(mag_temp[jj] > mag_max[jj]) mag_max[jj] = mag_temp[jj];  c8:	1c3b      	adds	r3, r7, #0  ca:	330c      	adds	r3, #12  cc:	6c3a      	ldr	r2, [r7, #64]	; 0x40  ce:	0052      	lsls	r2, r2, #1  d0:	5ad2      	ldrh	r2, [r2, r3]  d2:	1c3b      	adds	r3, r7, #0  d4:	331c      	adds	r3, #28  d6:	6c39      	ldr	r1, [r7, #64]	; 0x40  d8:	0049      	lsls	r1, r1, #1  da:	5acb      	ldrh	r3, [r1, r3]  dc:	b212      	sxth	r2, r2  de:	b21b      	sxth	r3, r3  e0:	429a      	cmp	r2, r3  e2:	dd09      	ble.n	f8 <magcalMPU9250+0xf8>  e4:	1c3b      	adds	r3, r7, #0  e6:	330c      	adds	r3, #12  e8:	6c3a      	ldr	r2, [r7, #64]	; 0x40  ea:	0052      	lsls	r2, r2, #1  ec:	5ad1      	ldrh	r1, [r2, r3]  ee:	1c3b      	adds	r3, r7, #0  f0:	331c      	adds	r3, #28  f2:	6c3a      	ldr	r2, [r7, #64]	; 0x40  f4:	0052      	lsls	r2, r2, #1  f6:	52d1      	strh	r1, [r2, r3]	      if(mag_temp[jj] < mag_min[jj]) mag_min[jj] = mag_temp[jj];  f8:	1c3b      	adds	r3, r7, #0  fa:	330c      	adds	r3, #12  fc:	6c3a      	ldr	r2, [r7, #64]	; 0x40  fe:	0052      	lsls	r2, r2, #1 100:	5ad2      	ldrh	r2, [r2, r3] 102:	1c3b      	adds	r3, r7, #0 104:	3314      	adds	r3, #20 106:	6c39      	ldr	r1, [r7, #64]	; 0x40 108:	0049      	lsls	r1, r1, #1 10a:	5acb      	ldrh	r3, [r1, r3] 10c:	b212      	sxth	r2, r2 10e:	b21b      	sxth	r3, r3 110:	429a      	cmp	r2, r3 112:	da09      	bge.n	128 <magcalMPU9250+0x128> 114:	1c3b      	adds	r3, r7, #0 116:	330c      	adds	r3, #12 118:	6c3a      	ldr	r2, [r7, #64]	; 0x40 11a:	0052      	lsls	r2, r2, #1 11c:	5ad1      	ldrh	r1, [r2, r3] 11e:	1c3b      	adds	r3, r7, #0 120:	3314      	adds	r3, #20 122:	6c3a      	ldr	r2, [r7, #64]	; 0x40 124:	0052      	lsls	r2, r2, #1 126:	52d1      	strh	r1, [r2, r3]	    if(mpu9250.Mmode == 0x02) sample_count = 128;  // at 8 Hz ODR, new mag data is available every 125 ms	    if(mpu9250.Mmode == 0x06) sample_count = 1500;  // at 100 Hz ODR, new mag data is available every 10 ms	    for(ii = 0; ii < sample_count; ii++) {	    readMagData(mag_temp);  // Read the mag data	    int jj;	    for (jj = 0; jj < 3; jj++) { 128:	6c3b      	ldr	r3, [r7, #64]	; 0x40 12a:	3301      	adds	r3, #1 12c:	643b      	str	r3, [r7, #64]	; 0x40 12e:	6c3b      	ldr	r3, [r7, #64]	; 0x40 130:	2b02      	cmp	r3, #2 132:	ddc9      	ble.n	c8 <magcalMPU9250+0xc8>	      if(mag_temp[jj] > mag_max[jj]) mag_max[jj] = mag_temp[jj];	      if(mag_temp[jj] < mag_min[jj]) mag_min[jj] = mag_temp[jj];	    }	    if(mpu9250.Mmode == 0x02) delay(135);  // at 8 Hz ODR, new mag data is available every 125 ms 134:	4b8b      	ldr	r3, [pc, #556]	; (364 <magcalMPU9250+0x364>) 136:	78db      	ldrb	r3, [r3, #3] 138:	2b02      	cmp	r3, #2 13a:	d102      	bne.n	142 <magcalMPU9250+0x142> 13c:	2087      	movs	r0, #135	; 0x87 13e:	f7ff fffe 	bl	0 <magcalMPU9250>			13e: R_ARM_THM_CALL	delay	    if(mpu9250.Mmode == 0x06) delay(12);  // at 100 Hz ODR, new mag data is available every 10 ms 142:	4b88      	ldr	r3, [pc, #544]	; (364 <magcalMPU9250+0x364>) 144:	78db      	ldrb	r3, [r3, #3] 146:	2b06      	cmp	r3, #6 148:	d102      	bne.n	150 <magcalMPU9250+0x150> 14a:	200c      	movs	r0, #12 14c:	f7ff fffe 	bl	0 <magcalMPU9250>			14c: R_ARM_THM_CALL	delay	  //delay(4000);	  	// shoot for ~fifteen seconds of mag data	    if(mpu9250.Mmode == 0x02) sample_count = 128;  // at 8 Hz ODR, new mag data is available every 125 ms	    if(mpu9250.Mmode == 0x06) sample_count = 1500;  // at 100 Hz ODR, new mag data is available every 10 ms	    for(ii = 0; ii < sample_count; ii++) { 150:	1c3b      	adds	r3, r7, #0 152:	3346      	adds	r3, #70	; 0x46 154:	1c3a      	adds	r2, r7, #0 156:	3246      	adds	r2, #70	; 0x46 158:	8812      	ldrh	r2, [r2, #0] 15a:	3201      	adds	r2, #1 15c:	801a      	strh	r2, [r3, #0] 15e:	1c3a      	adds	r2, r7, #0 160:	3246      	adds	r2, #70	; 0x46 162:	1c3b      	adds	r3, r7, #0 164:	3344      	adds	r3, #68	; 0x44 166:	8812      	ldrh	r2, [r2, #0] 168:	881b      	ldrh	r3, [r3, #0] 16a:	429a      	cmp	r2, r3 16c:	d3a4      	bcc.n	b8 <magcalMPU9250+0xb8>	    if(mpu9250.Mmode == 0x06) delay(12);  // at 100 Hz ODR, new mag data is available every 10 ms	    }	    // Get hard iron correction	    mag_bias[0]  = (mag_max[0] + mag_min[0])/2;  // get average x mag bias in counts 16e:	1c3b      	adds	r3, r7, #0 170:	331c      	adds	r3, #28 172:	881b      	ldrh	r3, [r3, #0] 174:	b21a      	sxth	r2, r3 176:	1c3b      	adds	r3, r7, #0 178:	3314      	adds	r3, #20 17a:	881b      	ldrh	r3, [r3, #0] 17c:	b21b      	sxth	r3, r3 17e:	18d3      	adds	r3, r2, r3 180:	2b00      	cmp	r3, #0 182:	da00      	bge.n	186 <magcalMPU9250+0x186> 184:	3301      	adds	r3, #1 186:	105b      	asrs	r3, r3, #1 188:	1c1a      	adds	r2, r3, #0 18a:	1c3b      	adds	r3, r7, #0 18c:	3330      	adds	r3, #48	; 0x30 18e:	601a      	str	r2, [r3, #0]	    mag_bias[1]  = (mag_max[1] + mag_min[1])/2;  // get average y mag bias in counts 190:	1c3b      	adds	r3, r7, #0 192:	331c      	adds	r3, #28 194:	885b      	ldrh	r3, [r3, #2] 196:	b21a      	sxth	r2, r3 198:	1c3b      	adds	r3, r7, #0 19a:	3314      	adds	r3, #20 19c:	885b      	ldrh	r3, [r3, #2] 19e:	b21b      	sxth	r3, r3 1a0:	18d3      	adds	r3, r2, r3 1a2:	2b00      	cmp	r3, #0 1a4:	da00      	bge.n	1a8 <magcalMPU9250+0x1a8> 1a6:	3301      	adds	r3, #1 1a8:	105b      	asrs	r3, r3, #1 1aa:	1c1a      	adds	r2, r3, #0 1ac:	1c3b      	adds	r3, r7, #0 1ae:	3330      	adds	r3, #48	; 0x30 1b0:	605a      	str	r2, [r3, #4]	    mag_bias[2]  = (mag_max[2] + mag_min[2])/2;  // get average z mag bias in counts 1b2:	1c3b      	adds	r3, r7, #0 1b4:	331c      	adds	r3, #28 1b6:	889b      	ldrh	r3, [r3, #4] 1b8:	b21a      	sxth	r2, r3 1ba:	1c3b      	adds	r3, r7, #0 1bc:	3314      	adds	r3, #20 1be:	889b      	ldrh	r3, [r3, #4] 1c0:	b21b      	sxth	r3, r3 1c2:	18d3      	adds	r3, r2, r3 1c4:	2b00      	cmp	r3, #0 1c6:	da00      	bge.n	1ca <magcalMPU9250+0x1ca> 1c8:	3301      	adds	r3, #1 1ca:	105b      	asrs	r3, r3, #1 1cc:	1c1a      	adds	r2, r3, #0 1ce:	1c3b      	adds	r3, r7, #0 1d0:	3330      	adds	r3, #48	; 0x30 1d2:	609a      	str	r2, [r3, #8]	    	    dest1[0] = (float) mag_bias[0]*mpu9250.mRes*mpu9250.magCalibration[0];  // save mag biases in G for main program 1d4:	1c3b      	adds	r3, r7, #0 1d6:	3330      	adds	r3, #48	; 0x30 1d8:	681b      	ldr	r3, [r3, #0] 1da:	1c18      	adds	r0, r3, #0 1dc:	f7ff fffe 	bl	0 <__aeabi_i2f>			1dc: R_ARM_THM_CALL	__aeabi_i2f 1e0:	1c02      	adds	r2, r0, #0 1e2:	4b60      	ldr	r3, [pc, #384]	; (364 <magcalMPU9250+0x364>) 1e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c 1e6:	1c10      	adds	r0, r2, #0 1e8:	1c19      	adds	r1, r3, #0 1ea:	f7ff fffe 	bl	0 <__aeabi_fmul>			1ea: R_ARM_THM_CALL	__aeabi_fmul 1ee:	1c03      	adds	r3, r0, #0 1f0:	1c1a      	adds	r2, r3, #0 1f2:	4b5c      	ldr	r3, [pc, #368]	; (364 <magcalMPU9250+0x364>) 1f4:	6f5b      	ldr	r3, [r3, #116]	; 0x74 1f6:	1c10      	adds	r0, r2, #0 1f8:	1c19      	adds	r1, r3, #0 1fa:	f7ff fffe 	bl	0 <__aeabi_fmul>			1fa: R_ARM_THM_CALL	__aeabi_fmul 1fe:	1c03      	adds	r3, r0, #0 200:	1c1a      	adds	r2, r3, #0 202:	687b      	ldr	r3, [r7, #4] 204:	601a      	str	r2, [r3, #0]	    dest1[1] = (float) mag_bias[1]*mpu9250.mRes*mpu9250.magCalibration[1];    206:	687b      	ldr	r3, [r7, #4] 208:	1d1c      	adds	r4, r3, #4 20a:	1c3b      	adds	r3, r7, #0 20c:	3330      	adds	r3, #48	; 0x30 20e:	685b      	ldr	r3, [r3, #4] 210:	1c18      	adds	r0, r3, #0 212:	f7ff fffe 	bl	0 <__aeabi_i2f>			212: R_ARM_THM_CALL	__aeabi_i2f 216:	1c02      	adds	r2, r0, #0 218:	4b52      	ldr	r3, [pc, #328]	; (364 <magcalMPU9250+0x364>) 21a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c 21c:	1c10      	adds	r0, r2, #0 21e:	1c19      	adds	r1, r3, #0 220:	f7ff fffe 	bl	0 <__aeabi_fmul>			220: R_ARM_THM_CALL	__aeabi_fmul 224:	1c03      	adds	r3, r0, #0 226:	1c1a      	adds	r2, r3, #0 228:	4b4e      	ldr	r3, [pc, #312]	; (364 <magcalMPU9250+0x364>) 22a:	6f9b      	ldr	r3, [r3, #120]	; 0x78 22c:	1c10      	adds	r0, r2, #0 22e:	1c19      	adds	r1, r3, #0 230:	f7ff fffe 	bl	0 <__aeabi_fmul>			230: R_ARM_THM_CALL	__aeabi_fmul 234:	1c03      	adds	r3, r0, #0 236:	6023      	str	r3, [r4, #0]	    dest1[2] = (float) mag_bias[2]*mpu9250.mRes*mpu9250.magCalibration[2];   238:	687b      	ldr	r3, [r7, #4] 23a:	1c1c      	adds	r4, r3, #0 23c:	3408      	adds	r4, #8 23e:	1c3b      	adds	r3, r7, #0 240:	3330      	adds	r3, #48	; 0x30 242:	689b      	ldr	r3, [r3, #8] 244:	1c18      	adds	r0, r3, #0 246:	f7ff fffe 	bl	0 <__aeabi_i2f>			246: R_ARM_THM_CALL	__aeabi_i2f 24a:	1c02      	adds	r2, r0, #0 24c:	4b45      	ldr	r3, [pc, #276]	; (364 <magcalMPU9250+0x364>) 24e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c 250:	1c10      	adds	r0, r2, #0 252:	1c19      	adds	r1, r3, #0 254:	f7ff fffe 	bl	0 <__aeabi_fmul>			254: R_ARM_THM_CALL	__aeabi_fmul 258:	1c03      	adds	r3, r0, #0 25a:	1c1a      	adds	r2, r3, #0 25c:	4b41      	ldr	r3, [pc, #260]	; (364 <magcalMPU9250+0x364>) 25e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c 260:	1c10      	adds	r0, r2, #0 262:	1c19      	adds	r1, r3, #0 264:	f7ff fffe 	bl	0 <__aeabi_fmul>			264: R_ARM_THM_CALL	__aeabi_fmul 268:	1c03      	adds	r3, r0, #0 26a:	6023      	str	r3, [r4, #0]	       	    // Get soft iron correction estimate	    mag_scale[0]  = (mag_max[0] - mag_min[0])/2;  // get average x axis max chord length in counts 26c:	1c3b      	adds	r3, r7, #0 26e:	331c      	adds	r3, #28 270:	881b      	ldrh	r3, [r3, #0] 272:	b21a      	sxth	r2, r3 274:	1c3b      	adds	r3, r7, #0 276:	3314      	adds	r3, #20 278:	881b      	ldrh	r3, [r3, #0] 27a:	b21b      	sxth	r3, r3 27c:	1ad3      	subs	r3, r2, r3 27e:	d500      	bpl.n	282 <magcalMPU9250+0x282> 280:	3301      	adds	r3, #1 282:	105b      	asrs	r3, r3, #1 284:	1c1a      	adds	r2, r3, #0 286:	1c3b      	adds	r3, r7, #0 288:	3324      	adds	r3, #36	; 0x24 28a:	601a      	str	r2, [r3, #0]	    mag_scale[1]  = (mag_max[1] - mag_min[1])/2;  // get average y axis max chord length in counts 28c:	1c3b      	adds	r3, r7, #0 28e:	331c      	adds	r3, #28 290:	885b      	ldrh	r3, [r3, #2] 292:	b21a      	sxth	r2, r3 294:	1c3b      	adds	r3, r7, #0 296:	3314      	adds	r3, #20 298:	885b      	ldrh	r3, [r3, #2] 29a:	b21b      	sxth	r3, r3 29c:	1ad3      	subs	r3, r2, r3 29e:	d500      	bpl.n	2a2 <magcalMPU9250+0x2a2> 2a0:	3301      	adds	r3, #1 2a2:	105b      	asrs	r3, r3, #1 2a4:	1c1a      	adds	r2, r3, #0 2a6:	1c3b      	adds	r3, r7, #0 2a8:	3324      	adds	r3, #36	; 0x24 2aa:	605a      	str	r2, [r3, #4]	    mag_scale[2]  = (mag_max[2] - mag_min[2])/2;  // get average z axis max chord length in counts 2ac:	1c3b      	adds	r3, r7, #0 2ae:	331c      	adds	r3, #28 2b0:	889b      	ldrh	r3, [r3, #4] 2b2:	b21a      	sxth	r2, r3 2b4:	1c3b      	adds	r3, r7, #0 2b6:	3314      	adds	r3, #20 2b8:	889b      	ldrh	r3, [r3, #4] 2ba:	b21b      	sxth	r3, r3 2bc:	1ad3      	subs	r3, r2, r3 2be:	d500      	bpl.n	2c2 <magcalMPU9250+0x2c2> 2c0:	3301      	adds	r3, #1 2c2:	105b      	asrs	r3, r3, #1 2c4:	1c1a      	adds	r2, r3, #0 2c6:	1c3b      	adds	r3, r7, #0 2c8:	3324      	adds	r3, #36	; 0x24 2ca:	609a      	str	r2, [r3, #8]	    float avg_rad = mag_scale[0] + mag_scale[1] + mag_scale[2]; 2cc:	1c3b      	adds	r3, r7, #0 2ce:	3324      	adds	r3, #36	; 0x24 2d0:	681a      	ldr	r2, [r3, #0] 2d2:	1c3b      	adds	r3, r7, #0 2d4:	3324      	adds	r3, #36	; 0x24 2d6:	685b      	ldr	r3, [r3, #4] 2d8:	18d2      	adds	r2, r2, r3 2da:	1c3b      	adds	r3, r7, #0 2dc:	3324      	adds	r3, #36	; 0x24 2de:	689b      	ldr	r3, [r3, #8] 2e0:	18d3      	adds	r3, r2, r3 2e2:	1c18      	adds	r0, r3, #0 2e4:	f7ff fffe 	bl	0 <__aeabi_i2f>			2e4: R_ARM_THM_CALL	__aeabi_i2f 2e8:	1c03      	adds	r3, r0, #0 2ea:	63fb      	str	r3, [r7, #60]	; 0x3c	    avg_rad /= 3.0; 2ec:	6bf8      	ldr	r0, [r7, #60]	; 0x3c 2ee:	491f      	ldr	r1, [pc, #124]	; (36c <magcalMPU9250+0x36c>) 2f0:	f7ff fffe 	bl	0 <__aeabi_fdiv>			2f0: R_ARM_THM_CALL	__aeabi_fdiv 2f4:	1c03      	adds	r3, r0, #0 2f6:	63fb      	str	r3, [r7, #60]	; 0x3c	    dest2[0] = avg_rad/((float)mag_scale[0]); 2f8:	1c3b      	adds	r3, r7, #0 2fa:	3324      	adds	r3, #36	; 0x24 2fc:	681b      	ldr	r3, [r3, #0] 2fe:	1c18      	adds	r0, r3, #0 300:	f7ff fffe 	bl	0 <__aeabi_i2f>			300: R_ARM_THM_CALL	__aeabi_i2f 304:	1c03      	adds	r3, r0, #0 306:	6bf8      	ldr	r0, [r7, #60]	; 0x3c 308:	1c19      	adds	r1, r3, #0 30a:	f7ff fffe 	bl	0 <__aeabi_fdiv>			30a: R_ARM_THM_CALL	__aeabi_fdiv 30e:	1c03      	adds	r3, r0, #0 310:	1c1a      	adds	r2, r3, #0 312:	683b      	ldr	r3, [r7, #0] 314:	601a      	str	r2, [r3, #0]	    dest2[1] = avg_rad/((float)mag_scale[1]); 316:	683b      	ldr	r3, [r7, #0] 318:	1d1c      	adds	r4, r3, #4 31a:	1c3b      	adds	r3, r7, #0 31c:	3324      	adds	r3, #36	; 0x24 31e:	685b      	ldr	r3, [r3, #4] 320:	1c18      	adds	r0, r3, #0 322:	f7ff fffe 	bl	0 <__aeabi_i2f>			322: R_ARM_THM_CALL	__aeabi_i2f 326:	1c03      	adds	r3, r0, #0 328:	6bf8      	ldr	r0, [r7, #60]	; 0x3c 32a:	1c19      	adds	r1, r3, #0 32c:	f7ff fffe 	bl	0 <__aeabi_fdiv>			32c: R_ARM_THM_CALL	__aeabi_fdiv 330:	1c03      	adds	r3, r0, #0 332:	6023      	str	r3, [r4, #0]	    dest2[2] = avg_rad/((float)mag_scale[2]); 334:	683b      	ldr	r3, [r7, #0] 336:	1c1c      	adds	r4, r3, #0 338:	3408      	adds	r4, #8 33a:	1c3b      	adds	r3, r7, #0 33c:	3324      	adds	r3, #36	; 0x24 33e:	689b      	ldr	r3, [r3, #8] 340:	1c18      	adds	r0, r3, #0 342:	f7ff fffe 	bl	0 <__aeabi_i2f>			342: R_ARM_THM_CALL	__aeabi_i2f 346:	1c03      	adds	r3, r0, #0 348:	6bf8      	ldr	r0, [r7, #60]	; 0x3c 34a:	1c19      	adds	r1, r3, #0 34c:	f7ff fffe 	bl	0 <__aeabi_fdiv>			34c: R_ARM_THM_CALL	__aeabi_fdiv 350:	1c03      	adds	r3, r0, #0 352:	6023      	str	r3, [r4, #0]	  	   //Serial.println("Mag Calibration done!");} 354:	46bd      	mov	sp, r7 356:	b013      	add	sp, #76	; 0x4c 358:	bd90      	pop	{r4, r7, pc} 35a:	46c0      	nop			; (mov r8, r8) 35c:	00000000 	.word	0x00000000			35c: R_ARM_ABS32	.rodata 360:	00000008 	.word	0x00000008			360: R_ARM_ABS32	.rodata 364:	00000000 	.word	0x00000000			364: R_ARM_ABS32	mpu9250 368:	000005dc 	.word	0x000005dc 36c:	40400000 	.word	0x40400000Disassembly of section .text.calibrateMPU9250:00000000 <calibrateMPU9250>:void calibrateMPU9250(float * dest1, float * dest2){     0:	b5b0      	push	{r4, r5, r7, lr}   2:	b098      	sub	sp, #96	; 0x60   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]   8:	6039      	str	r1, [r7, #0]  uint8_t data[12]; // data array to hold accelerometer and gyro x, y, z, data  uint16_t ii, packet_count, fifo_count;  int32_t gyro_bias[3]  = {0, 0, 0}, accel_bias[3] = {0, 0, 0};   a:	1c3b      	adds	r3, r7, #0   c:	3338      	adds	r3, #56	; 0x38   e:	2200      	movs	r2, #0  10:	601a      	str	r2, [r3, #0]  12:	1c3b      	adds	r3, r7, #0  14:	3338      	adds	r3, #56	; 0x38  16:	2200      	movs	r2, #0  18:	605a      	str	r2, [r3, #4]  1a:	1c3b      	adds	r3, r7, #0  1c:	3338      	adds	r3, #56	; 0x38  1e:	2200      	movs	r2, #0  20:	609a      	str	r2, [r3, #8]  22:	1c3b      	adds	r3, r7, #0  24:	332c      	adds	r3, #44	; 0x2c  26:	2200      	movs	r2, #0  28:	601a      	str	r2, [r3, #0]  2a:	1c3b      	adds	r3, r7, #0  2c:	332c      	adds	r3, #44	; 0x2c  2e:	2200      	movs	r2, #0  30:	605a      	str	r2, [r3, #4]  32:	1c3b      	adds	r3, r7, #0  34:	332c      	adds	r3, #44	; 0x2c  36:	2200      	movs	r2, #0  38:	609a      	str	r2, [r3, #8]   // reset device  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x80); // Write a one to bit 7 reset bit; toggle reset device  3a:	2068      	movs	r0, #104	; 0x68  3c:	216b      	movs	r1, #107	; 0x6b  3e:	2280      	movs	r2, #128	; 0x80  40:	f7ff fffe 	bl	0 <writeByte>			40: R_ARM_THM_CALL	writeByte  delay(100);  44:	2064      	movs	r0, #100	; 0x64  46:	f7ff fffe 	bl	0 <calibrateMPU9250>			46: R_ARM_THM_CALL	delay    // get stable time source; Auto select clock source to be PLL gyroscope reference if ready  // else use the internal oscillator, bits 2:0 = 001  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x01);    4a:	2068      	movs	r0, #104	; 0x68  4c:	216b      	movs	r1, #107	; 0x6b  4e:	2201      	movs	r2, #1  50:	f7ff fffe 	bl	0 <writeByte>			50: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, PWR_MGMT_2, 0x00);  54:	2068      	movs	r0, #104	; 0x68  56:	216c      	movs	r1, #108	; 0x6c  58:	2200      	movs	r2, #0  5a:	f7ff fffe 	bl	0 <writeByte>			5a: R_ARM_THM_CALL	writeByte  delay(200);                                      5e:	20c8      	movs	r0, #200	; 0xc8  60:	f7ff fffe 	bl	0 <calibrateMPU9250>			60: R_ARM_THM_CALL	delay// Configure device for bias calculation  writeByte(MPU9250_ADDRESS, INT_ENABLE, 0x00);   // Disable all interrupts  64:	2068      	movs	r0, #104	; 0x68  66:	2138      	movs	r1, #56	; 0x38  68:	2200      	movs	r2, #0  6a:	f7ff fffe 	bl	0 <writeByte>			6a: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, FIFO_EN, 0x00);      // Disable FIFO  6e:	2068      	movs	r0, #104	; 0x68  70:	2123      	movs	r1, #35	; 0x23  72:	2200      	movs	r2, #0  74:	f7ff fffe 	bl	0 <writeByte>			74: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x00);   // Turn on internal clock source  78:	2068      	movs	r0, #104	; 0x68  7a:	216b      	movs	r1, #107	; 0x6b  7c:	2200      	movs	r2, #0  7e:	f7ff fffe 	bl	0 <writeByte>			7e: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, I2C_MST_CTRL, 0x00); // Disable I2C master  82:	2068      	movs	r0, #104	; 0x68  84:	2124      	movs	r1, #36	; 0x24  86:	2200      	movs	r2, #0  88:	f7ff fffe 	bl	0 <writeByte>			88: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, USER_CTRL, 0x00);    // Disable FIFO and I2C master modes  8c:	2068      	movs	r0, #104	; 0x68  8e:	216a      	movs	r1, #106	; 0x6a  90:	2200      	movs	r2, #0  92:	f7ff fffe 	bl	0 <writeByte>			92: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, USER_CTRL, 0x0C);    // Reset FIFO and DMP  96:	2068      	movs	r0, #104	; 0x68  98:	216a      	movs	r1, #106	; 0x6a  9a:	220c      	movs	r2, #12  9c:	f7ff fffe 	bl	0 <writeByte>			9c: R_ARM_THM_CALL	writeByte  delay(15);  a0:	200f      	movs	r0, #15  a2:	f7ff fffe 	bl	0 <calibrateMPU9250>			a2: R_ARM_THM_CALL	delay  // Configure MPU6050 gyro and accelerometer for bias calculation  writeByte(MPU9250_ADDRESS, CONFIG, 0x01);      // Set low-pass filter to 188 Hz  a6:	2068      	movs	r0, #104	; 0x68  a8:	211a      	movs	r1, #26  aa:	2201      	movs	r2, #1  ac:	f7ff fffe 	bl	0 <writeByte>			ac: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, SMPLRT_DIV, 0x00);  // Set sample rate to 1 kHz  b0:	2068      	movs	r0, #104	; 0x68  b2:	2119      	movs	r1, #25  b4:	2200      	movs	r2, #0  b6:	f7ff fffe 	bl	0 <writeByte>			b6: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, GYRO_CONFIG, 0x00);  // Set gyro full-scale to 250 degrees per second, maximum sensitivity  ba:	2068      	movs	r0, #104	; 0x68  bc:	211b      	movs	r1, #27  be:	2200      	movs	r2, #0  c0:	f7ff fffe 	bl	0 <writeByte>			c0: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG, 0x00); // Set accelerometer full-scale to 2 g, maximum sensitivity  c4:	2068      	movs	r0, #104	; 0x68  c6:	211c      	movs	r1, #28  c8:	2200      	movs	r2, #0  ca:	f7ff fffe 	bl	0 <writeByte>			ca: R_ARM_THM_CALL	writeByte   uint16_t  gyrosensitivity  = 131;   // = 131 LSB/degrees/sec  ce:	1c3b      	adds	r3, r7, #0  d0:	335c      	adds	r3, #92	; 0x5c  d2:	2283      	movs	r2, #131	; 0x83  d4:	801a      	strh	r2, [r3, #0]  uint16_t  accelsensitivity = 16384;  // = 16384 LSB/g  d6:	1c3b      	adds	r3, r7, #0  d8:	335a      	adds	r3, #90	; 0x5a  da:	2280      	movs	r2, #128	; 0x80  dc:	01d2      	lsls	r2, r2, #7  de:	801a      	strh	r2, [r3, #0]    // Configure FIFO to capture accelerometer and gyro data for bias calculation  writeByte(MPU9250_ADDRESS, USER_CTRL, 0x40);   // Enable FIFO    e0:	2068      	movs	r0, #104	; 0x68  e2:	216a      	movs	r1, #106	; 0x6a  e4:	2240      	movs	r2, #64	; 0x40  e6:	f7ff fffe 	bl	0 <writeByte>			e6: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, FIFO_EN, 0x78);     // Enable gyro and accelerometer sensors for FIFO  (max size 512 bytes in MPU-9150)  ea:	2068      	movs	r0, #104	; 0x68  ec:	2123      	movs	r1, #35	; 0x23  ee:	2278      	movs	r2, #120	; 0x78  f0:	f7ff fffe 	bl	0 <writeByte>			f0: R_ARM_THM_CALL	writeByte  delay(40); // accumulate 40 samples in 40 milliseconds = 480 bytes  f4:	2028      	movs	r0, #40	; 0x28  f6:	f7ff fffe 	bl	0 <calibrateMPU9250>			f6: R_ARM_THM_CALL	delay// At end of sample accumulation, turn off FIFO sensor read  writeByte(MPU9250_ADDRESS, FIFO_EN, 0x00);        // Disable gyro and accelerometer sensors for FIFO  fa:	2068      	movs	r0, #104	; 0x68  fc:	2123      	movs	r1, #35	; 0x23  fe:	2200      	movs	r2, #0 100:	f7ff fffe 	bl	0 <writeByte>			100: R_ARM_THM_CALL	writeByte  readBytes(MPU9250_ADDRESS, FIFO_COUNTH, 2, &data[0]); // read FIFO sample count 104:	1c3b      	adds	r3, r7, #0 106:	3344      	adds	r3, #68	; 0x44 108:	2068      	movs	r0, #104	; 0x68 10a:	2172      	movs	r1, #114	; 0x72 10c:	2202      	movs	r2, #2 10e:	f7ff fffe 	bl	0 <readBytes>			10e: R_ARM_THM_CALL	readBytes  fifo_count = ((uint16_t)data[0] << 8) | data[1]; 112:	1c3b      	adds	r3, r7, #0 114:	3344      	adds	r3, #68	; 0x44 116:	781b      	ldrb	r3, [r3, #0] 118:	021b      	lsls	r3, r3, #8 11a:	b29a      	uxth	r2, r3 11c:	1c3b      	adds	r3, r7, #0 11e:	3344      	adds	r3, #68	; 0x44 120:	785b      	ldrb	r3, [r3, #1] 122:	4313      	orrs	r3, r2 124:	b29a      	uxth	r2, r3 126:	1c3b      	adds	r3, r7, #0 128:	3358      	adds	r3, #88	; 0x58 12a:	801a      	strh	r2, [r3, #0]  packet_count = fifo_count/12;// How many sets of full gyro and accelerometer data for averaging 12c:	1c3c      	adds	r4, r7, #0 12e:	3456      	adds	r4, #86	; 0x56 130:	1c3b      	adds	r3, r7, #0 132:	3358      	adds	r3, #88	; 0x58 134:	881b      	ldrh	r3, [r3, #0] 136:	1c18      	adds	r0, r3, #0 138:	210c      	movs	r1, #12 13a:	f7ff fffe 	bl	0 <__aeabi_uidiv>			13a: R_ARM_THM_CALL	__aeabi_uidiv 13e:	1c03      	adds	r3, r0, #0 140:	8023      	strh	r3, [r4, #0]    for (ii = 0; ii < packet_count; ii++) { 142:	1c3b      	adds	r3, r7, #0 144:	335e      	adds	r3, #94	; 0x5e 146:	2200      	movs	r2, #0 148:	801a      	strh	r2, [r3, #0] 14a:	e0b5      	b.n	2b8 <calibrateMPU9250+0x2b8>    int16_t accel_temp[3] = {0, 0, 0}, gyro_temp[3] = {0, 0, 0}; 14c:	1c3b      	adds	r3, r7, #0 14e:	3314      	adds	r3, #20 150:	2200      	movs	r2, #0 152:	801a      	strh	r2, [r3, #0] 154:	1c3b      	adds	r3, r7, #0 156:	3314      	adds	r3, #20 158:	2200      	movs	r2, #0 15a:	805a      	strh	r2, [r3, #2] 15c:	1c3b      	adds	r3, r7, #0 15e:	3314      	adds	r3, #20 160:	2200      	movs	r2, #0 162:	809a      	strh	r2, [r3, #4] 164:	1c3b      	adds	r3, r7, #0 166:	330c      	adds	r3, #12 168:	2200      	movs	r2, #0 16a:	801a      	strh	r2, [r3, #0] 16c:	1c3b      	adds	r3, r7, #0 16e:	330c      	adds	r3, #12 170:	2200      	movs	r2, #0 172:	805a      	strh	r2, [r3, #2] 174:	1c3b      	adds	r3, r7, #0 176:	330c      	adds	r3, #12 178:	2200      	movs	r2, #0 17a:	809a      	strh	r2, [r3, #4]    readBytes(MPU9250_ADDRESS, FIFO_R_W, 12, &data[0]); // read data for averaging 17c:	1c3b      	adds	r3, r7, #0 17e:	3344      	adds	r3, #68	; 0x44 180:	2068      	movs	r0, #104	; 0x68 182:	2174      	movs	r1, #116	; 0x74 184:	220c      	movs	r2, #12 186:	f7ff fffe 	bl	0 <readBytes>			186: R_ARM_THM_CALL	readBytes    accel_temp[0] = (int16_t) (((int16_t)data[0] << 8) | data[1]  ) ;  // Form signed 16-bit integer for each sample in FIFO 18a:	1c3b      	adds	r3, r7, #0 18c:	3344      	adds	r3, #68	; 0x44 18e:	781b      	ldrb	r3, [r3, #0] 190:	021b      	lsls	r3, r3, #8 192:	b29a      	uxth	r2, r3 194:	1c3b      	adds	r3, r7, #0 196:	3344      	adds	r3, #68	; 0x44 198:	785b      	ldrb	r3, [r3, #1] 19a:	4313      	orrs	r3, r2 19c:	b29a      	uxth	r2, r3 19e:	1c3b      	adds	r3, r7, #0 1a0:	3314      	adds	r3, #20 1a2:	801a      	strh	r2, [r3, #0]    accel_temp[1] = (int16_t) (((int16_t)data[2] << 8) | data[3]  ) ; 1a4:	1c3b      	adds	r3, r7, #0 1a6:	3344      	adds	r3, #68	; 0x44 1a8:	789b      	ldrb	r3, [r3, #2] 1aa:	021b      	lsls	r3, r3, #8 1ac:	b29a      	uxth	r2, r3 1ae:	1c3b      	adds	r3, r7, #0 1b0:	3344      	adds	r3, #68	; 0x44 1b2:	78db      	ldrb	r3, [r3, #3] 1b4:	4313      	orrs	r3, r2 1b6:	b29a      	uxth	r2, r3 1b8:	1c3b      	adds	r3, r7, #0 1ba:	3314      	adds	r3, #20 1bc:	805a      	strh	r2, [r3, #2]    accel_temp[2] = (int16_t) (((int16_t)data[4] << 8) | data[5]  ) ;     1be:	1c3b      	adds	r3, r7, #0 1c0:	3344      	adds	r3, #68	; 0x44 1c2:	791b      	ldrb	r3, [r3, #4] 1c4:	021b      	lsls	r3, r3, #8 1c6:	b29a      	uxth	r2, r3 1c8:	1c3b      	adds	r3, r7, #0 1ca:	3344      	adds	r3, #68	; 0x44 1cc:	795b      	ldrb	r3, [r3, #5] 1ce:	4313      	orrs	r3, r2 1d0:	b29a      	uxth	r2, r3 1d2:	1c3b      	adds	r3, r7, #0 1d4:	3314      	adds	r3, #20 1d6:	809a      	strh	r2, [r3, #4]    gyro_temp[0]  = (int16_t) (((int16_t)data[6] << 8) | data[7]  ) ; 1d8:	1c3b      	adds	r3, r7, #0 1da:	3344      	adds	r3, #68	; 0x44 1dc:	799b      	ldrb	r3, [r3, #6] 1de:	021b      	lsls	r3, r3, #8 1e0:	b29a      	uxth	r2, r3 1e2:	1c3b      	adds	r3, r7, #0 1e4:	3344      	adds	r3, #68	; 0x44 1e6:	79db      	ldrb	r3, [r3, #7] 1e8:	4313      	orrs	r3, r2 1ea:	b29a      	uxth	r2, r3 1ec:	1c3b      	adds	r3, r7, #0 1ee:	330c      	adds	r3, #12 1f0:	801a      	strh	r2, [r3, #0]    gyro_temp[1]  = (int16_t) (((int16_t)data[8] << 8) | data[9]  ) ; 1f2:	1c3b      	adds	r3, r7, #0 1f4:	3344      	adds	r3, #68	; 0x44 1f6:	7a1b      	ldrb	r3, [r3, #8] 1f8:	021b      	lsls	r3, r3, #8 1fa:	b29a      	uxth	r2, r3 1fc:	1c3b      	adds	r3, r7, #0 1fe:	3344      	adds	r3, #68	; 0x44 200:	7a5b      	ldrb	r3, [r3, #9] 202:	4313      	orrs	r3, r2 204:	b29a      	uxth	r2, r3 206:	1c3b      	adds	r3, r7, #0 208:	330c      	adds	r3, #12 20a:	805a      	strh	r2, [r3, #2]    gyro_temp[2]  = (int16_t) (((int16_t)data[10] << 8) | data[11]) ; 20c:	1c3b      	adds	r3, r7, #0 20e:	3344      	adds	r3, #68	; 0x44 210:	7a9b      	ldrb	r3, [r3, #10] 212:	021b      	lsls	r3, r3, #8 214:	b29a      	uxth	r2, r3 216:	1c3b      	adds	r3, r7, #0 218:	3344      	adds	r3, #68	; 0x44 21a:	7adb      	ldrb	r3, [r3, #11] 21c:	4313      	orrs	r3, r2 21e:	b29a      	uxth	r2, r3 220:	1c3b      	adds	r3, r7, #0 222:	330c      	adds	r3, #12 224:	809a      	strh	r2, [r3, #4]        accel_bias[0] += (int32_t) accel_temp[0]; // Sum individual signed 16-bit biases to get accumulated signed 32-bit biases 226:	1c3b      	adds	r3, r7, #0 228:	332c      	adds	r3, #44	; 0x2c 22a:	681a      	ldr	r2, [r3, #0] 22c:	1c3b      	adds	r3, r7, #0 22e:	3314      	adds	r3, #20 230:	881b      	ldrh	r3, [r3, #0] 232:	b21b      	sxth	r3, r3 234:	18d2      	adds	r2, r2, r3 236:	1c3b      	adds	r3, r7, #0 238:	332c      	adds	r3, #44	; 0x2c 23a:	601a      	str	r2, [r3, #0]    accel_bias[1] += (int32_t) accel_temp[1]; 23c:	1c3b      	adds	r3, r7, #0 23e:	332c      	adds	r3, #44	; 0x2c 240:	685a      	ldr	r2, [r3, #4] 242:	1c3b      	adds	r3, r7, #0 244:	3314      	adds	r3, #20 246:	885b      	ldrh	r3, [r3, #2] 248:	b21b      	sxth	r3, r3 24a:	18d2      	adds	r2, r2, r3 24c:	1c3b      	adds	r3, r7, #0 24e:	332c      	adds	r3, #44	; 0x2c 250:	605a      	str	r2, [r3, #4]    accel_bias[2] += (int32_t) accel_temp[2]; 252:	1c3b      	adds	r3, r7, #0 254:	332c      	adds	r3, #44	; 0x2c 256:	689a      	ldr	r2, [r3, #8] 258:	1c3b      	adds	r3, r7, #0 25a:	3314      	adds	r3, #20 25c:	889b      	ldrh	r3, [r3, #4] 25e:	b21b      	sxth	r3, r3 260:	18d2      	adds	r2, r2, r3 262:	1c3b      	adds	r3, r7, #0 264:	332c      	adds	r3, #44	; 0x2c 266:	609a      	str	r2, [r3, #8]    gyro_bias[0]  += (int32_t) gyro_temp[0]; 268:	1c3b      	adds	r3, r7, #0 26a:	3338      	adds	r3, #56	; 0x38 26c:	681a      	ldr	r2, [r3, #0] 26e:	1c3b      	adds	r3, r7, #0 270:	330c      	adds	r3, #12 272:	881b      	ldrh	r3, [r3, #0] 274:	b21b      	sxth	r3, r3 276:	18d2      	adds	r2, r2, r3 278:	1c3b      	adds	r3, r7, #0 27a:	3338      	adds	r3, #56	; 0x38 27c:	601a      	str	r2, [r3, #0]    gyro_bias[1]  += (int32_t) gyro_temp[1]; 27e:	1c3b      	adds	r3, r7, #0 280:	3338      	adds	r3, #56	; 0x38 282:	685a      	ldr	r2, [r3, #4] 284:	1c3b      	adds	r3, r7, #0 286:	330c      	adds	r3, #12 288:	885b      	ldrh	r3, [r3, #2] 28a:	b21b      	sxth	r3, r3 28c:	18d2      	adds	r2, r2, r3 28e:	1c3b      	adds	r3, r7, #0 290:	3338      	adds	r3, #56	; 0x38 292:	605a      	str	r2, [r3, #4]    gyro_bias[2]  += (int32_t) gyro_temp[2]; 294:	1c3b      	adds	r3, r7, #0 296:	3338      	adds	r3, #56	; 0x38 298:	689a      	ldr	r2, [r3, #8] 29a:	1c3b      	adds	r3, r7, #0 29c:	330c      	adds	r3, #12 29e:	889b      	ldrh	r3, [r3, #4] 2a0:	b21b      	sxth	r3, r3 2a2:	18d2      	adds	r2, r2, r3 2a4:	1c3b      	adds	r3, r7, #0 2a6:	3338      	adds	r3, #56	; 0x38 2a8:	609a      	str	r2, [r3, #8]  writeByte(MPU9250_ADDRESS, FIFO_EN, 0x00);        // Disable gyro and accelerometer sensors for FIFO  readBytes(MPU9250_ADDRESS, FIFO_COUNTH, 2, &data[0]); // read FIFO sample count  fifo_count = ((uint16_t)data[0] << 8) | data[1];  packet_count = fifo_count/12;// How many sets of full gyro and accelerometer data for averaging    for (ii = 0; ii < packet_count; ii++) { 2aa:	1c3b      	adds	r3, r7, #0 2ac:	335e      	adds	r3, #94	; 0x5e 2ae:	1c3a      	adds	r2, r7, #0 2b0:	325e      	adds	r2, #94	; 0x5e 2b2:	8812      	ldrh	r2, [r2, #0] 2b4:	3201      	adds	r2, #1 2b6:	801a      	strh	r2, [r3, #0] 2b8:	1c3a      	adds	r2, r7, #0 2ba:	325e      	adds	r2, #94	; 0x5e 2bc:	1c3b      	adds	r3, r7, #0 2be:	3356      	adds	r3, #86	; 0x56 2c0:	8812      	ldrh	r2, [r2, #0] 2c2:	881b      	ldrh	r3, [r3, #0] 2c4:	429a      	cmp	r2, r3 2c6:	d200      	bcs.n	2ca <calibrateMPU9250+0x2ca> 2c8:	e740      	b.n	14c <calibrateMPU9250+0x14c>    gyro_bias[0]  += (int32_t) gyro_temp[0];    gyro_bias[1]  += (int32_t) gyro_temp[1];    gyro_bias[2]  += (int32_t) gyro_temp[2];            }    accel_bias[0] /= (int32_t) packet_count; // Normalize sums to get average count biases 2ca:	1c3b      	adds	r3, r7, #0 2cc:	332c      	adds	r3, #44	; 0x2c 2ce:	681a      	ldr	r2, [r3, #0] 2d0:	1c3b      	adds	r3, r7, #0 2d2:	3356      	adds	r3, #86	; 0x56 2d4:	881b      	ldrh	r3, [r3, #0] 2d6:	1c10      	adds	r0, r2, #0 2d8:	1c19      	adds	r1, r3, #0 2da:	f7ff fffe 	bl	0 <__aeabi_idiv>			2da: R_ARM_THM_CALL	__aeabi_idiv 2de:	1c03      	adds	r3, r0, #0 2e0:	1c1a      	adds	r2, r3, #0 2e2:	1c3b      	adds	r3, r7, #0 2e4:	332c      	adds	r3, #44	; 0x2c 2e6:	601a      	str	r2, [r3, #0]    accel_bias[1] /= (int32_t) packet_count; 2e8:	1c3b      	adds	r3, r7, #0 2ea:	332c      	adds	r3, #44	; 0x2c 2ec:	685a      	ldr	r2, [r3, #4] 2ee:	1c3b      	adds	r3, r7, #0 2f0:	3356      	adds	r3, #86	; 0x56 2f2:	881b      	ldrh	r3, [r3, #0] 2f4:	1c10      	adds	r0, r2, #0 2f6:	1c19      	adds	r1, r3, #0 2f8:	f7ff fffe 	bl	0 <__aeabi_idiv>			2f8: R_ARM_THM_CALL	__aeabi_idiv 2fc:	1c03      	adds	r3, r0, #0 2fe:	1c1a      	adds	r2, r3, #0 300:	1c3b      	adds	r3, r7, #0 302:	332c      	adds	r3, #44	; 0x2c 304:	605a      	str	r2, [r3, #4]    accel_bias[2] /= (int32_t) packet_count; 306:	1c3b      	adds	r3, r7, #0 308:	332c      	adds	r3, #44	; 0x2c 30a:	689a      	ldr	r2, [r3, #8] 30c:	1c3b      	adds	r3, r7, #0 30e:	3356      	adds	r3, #86	; 0x56 310:	881b      	ldrh	r3, [r3, #0] 312:	1c10      	adds	r0, r2, #0 314:	1c19      	adds	r1, r3, #0 316:	f7ff fffe 	bl	0 <__aeabi_idiv>			316: R_ARM_THM_CALL	__aeabi_idiv 31a:	1c03      	adds	r3, r0, #0 31c:	1c1a      	adds	r2, r3, #0 31e:	1c3b      	adds	r3, r7, #0 320:	332c      	adds	r3, #44	; 0x2c 322:	609a      	str	r2, [r3, #8]    gyro_bias[0]  /= (int32_t) packet_count; 324:	1c3b      	adds	r3, r7, #0 326:	3338      	adds	r3, #56	; 0x38 328:	681a      	ldr	r2, [r3, #0] 32a:	1c3b      	adds	r3, r7, #0 32c:	3356      	adds	r3, #86	; 0x56 32e:	881b      	ldrh	r3, [r3, #0] 330:	1c10      	adds	r0, r2, #0 332:	1c19      	adds	r1, r3, #0 334:	f7ff fffe 	bl	0 <__aeabi_idiv>			334: R_ARM_THM_CALL	__aeabi_idiv 338:	1c03      	adds	r3, r0, #0 33a:	1c1a      	adds	r2, r3, #0 33c:	1c3b      	adds	r3, r7, #0 33e:	3338      	adds	r3, #56	; 0x38 340:	601a      	str	r2, [r3, #0]    gyro_bias[1]  /= (int32_t) packet_count; 342:	1c3b      	adds	r3, r7, #0 344:	3338      	adds	r3, #56	; 0x38 346:	685a      	ldr	r2, [r3, #4] 348:	1c3b      	adds	r3, r7, #0 34a:	3356      	adds	r3, #86	; 0x56 34c:	881b      	ldrh	r3, [r3, #0] 34e:	1c10      	adds	r0, r2, #0 350:	1c19      	adds	r1, r3, #0 352:	f7ff fffe 	bl	0 <__aeabi_idiv>			352: R_ARM_THM_CALL	__aeabi_idiv 356:	1c03      	adds	r3, r0, #0 358:	1c1a      	adds	r2, r3, #0 35a:	1c3b      	adds	r3, r7, #0 35c:	3338      	adds	r3, #56	; 0x38 35e:	605a      	str	r2, [r3, #4]    gyro_bias[2]  /= (int32_t) packet_count; 360:	1c3b      	adds	r3, r7, #0 362:	3338      	adds	r3, #56	; 0x38 364:	689a      	ldr	r2, [r3, #8] 366:	1c3b      	adds	r3, r7, #0 368:	3356      	adds	r3, #86	; 0x56 36a:	881b      	ldrh	r3, [r3, #0] 36c:	1c10      	adds	r0, r2, #0 36e:	1c19      	adds	r1, r3, #0 370:	f7ff fffe 	bl	0 <__aeabi_idiv>			370: R_ARM_THM_CALL	__aeabi_idiv 374:	1c03      	adds	r3, r0, #0 376:	1c1a      	adds	r2, r3, #0 378:	1c3b      	adds	r3, r7, #0 37a:	3338      	adds	r3, #56	; 0x38 37c:	609a      	str	r2, [r3, #8]      if(accel_bias[2] > 0L) {accel_bias[2] -= (int32_t) accelsensitivity;}  // Remove gravity from the z-axis accelerometer bias calculation 37e:	1c3b      	adds	r3, r7, #0 380:	332c      	adds	r3, #44	; 0x2c 382:	689b      	ldr	r3, [r3, #8] 384:	2b00      	cmp	r3, #0 386:	dd0a      	ble.n	39e <calibrateMPU9250+0x39e> 388:	1c3b      	adds	r3, r7, #0 38a:	332c      	adds	r3, #44	; 0x2c 38c:	689a      	ldr	r2, [r3, #8] 38e:	1c3b      	adds	r3, r7, #0 390:	335a      	adds	r3, #90	; 0x5a 392:	881b      	ldrh	r3, [r3, #0] 394:	1ad2      	subs	r2, r2, r3 396:	1c3b      	adds	r3, r7, #0 398:	332c      	adds	r3, #44	; 0x2c 39a:	609a      	str	r2, [r3, #8] 39c:	e009      	b.n	3b2 <calibrateMPU9250+0x3b2>  else {accel_bias[2] += (int32_t) accelsensitivity;} 39e:	1c3b      	adds	r3, r7, #0 3a0:	332c      	adds	r3, #44	; 0x2c 3a2:	689a      	ldr	r2, [r3, #8] 3a4:	1c3b      	adds	r3, r7, #0 3a6:	335a      	adds	r3, #90	; 0x5a 3a8:	881b      	ldrh	r3, [r3, #0] 3aa:	18d2      	adds	r2, r2, r3 3ac:	1c3b      	adds	r3, r7, #0 3ae:	332c      	adds	r3, #44	; 0x2c 3b0:	609a      	str	r2, [r3, #8]   // Construct the gyro biases for push to the hardware gyro bias registers, which are reset to zero upon device startup  data[0] = (-gyro_bias[0]/4  >> 8) & 0xFF; // Divide by 4 to get 32.9 LSB per deg/s to conform to expected bias input format 3b2:	1c3b      	adds	r3, r7, #0 3b4:	3338      	adds	r3, #56	; 0x38 3b6:	681b      	ldr	r3, [r3, #0] 3b8:	425b      	negs	r3, r3 3ba:	2b00      	cmp	r3, #0 3bc:	da00      	bge.n	3c0 <calibrateMPU9250+0x3c0> 3be:	3303      	adds	r3, #3 3c0:	109b      	asrs	r3, r3, #2 3c2:	121b      	asrs	r3, r3, #8 3c4:	b2da      	uxtb	r2, r3 3c6:	1c3b      	adds	r3, r7, #0 3c8:	3344      	adds	r3, #68	; 0x44 3ca:	701a      	strb	r2, [r3, #0]  data[1] = (-gyro_bias[0]/4)       & 0xFF; // Biases are additive, so change sign on calculated average gyro biases 3cc:	1c3b      	adds	r3, r7, #0 3ce:	3338      	adds	r3, #56	; 0x38 3d0:	681b      	ldr	r3, [r3, #0] 3d2:	425b      	negs	r3, r3 3d4:	2b00      	cmp	r3, #0 3d6:	da00      	bge.n	3da <calibrateMPU9250+0x3da> 3d8:	3303      	adds	r3, #3 3da:	109b      	asrs	r3, r3, #2 3dc:	b2da      	uxtb	r2, r3 3de:	1c3b      	adds	r3, r7, #0 3e0:	3344      	adds	r3, #68	; 0x44 3e2:	705a      	strb	r2, [r3, #1]  data[2] = (-gyro_bias[1]/4  >> 8) & 0xFF; 3e4:	1c3b      	adds	r3, r7, #0 3e6:	3338      	adds	r3, #56	; 0x38 3e8:	685b      	ldr	r3, [r3, #4] 3ea:	425b      	negs	r3, r3 3ec:	2b00      	cmp	r3, #0 3ee:	da00      	bge.n	3f2 <calibrateMPU9250+0x3f2> 3f0:	3303      	adds	r3, #3 3f2:	109b      	asrs	r3, r3, #2 3f4:	121b      	asrs	r3, r3, #8 3f6:	b2da      	uxtb	r2, r3 3f8:	1c3b      	adds	r3, r7, #0 3fa:	3344      	adds	r3, #68	; 0x44 3fc:	709a      	strb	r2, [r3, #2]  data[3] = (-gyro_bias[1]/4)       & 0xFF; 3fe:	1c3b      	adds	r3, r7, #0 400:	3338      	adds	r3, #56	; 0x38 402:	685b      	ldr	r3, [r3, #4] 404:	425b      	negs	r3, r3 406:	2b00      	cmp	r3, #0 408:	da00      	bge.n	40c <calibrateMPU9250+0x40c> 40a:	3303      	adds	r3, #3 40c:	109b      	asrs	r3, r3, #2 40e:	b2da      	uxtb	r2, r3 410:	1c3b      	adds	r3, r7, #0 412:	3344      	adds	r3, #68	; 0x44 414:	70da      	strb	r2, [r3, #3]  data[4] = (-gyro_bias[2]/4  >> 8) & 0xFF; 416:	1c3b      	adds	r3, r7, #0 418:	3338      	adds	r3, #56	; 0x38 41a:	689b      	ldr	r3, [r3, #8] 41c:	425b      	negs	r3, r3 41e:	2b00      	cmp	r3, #0 420:	da00      	bge.n	424 <calibrateMPU9250+0x424> 422:	3303      	adds	r3, #3 424:	109b      	asrs	r3, r3, #2 426:	121b      	asrs	r3, r3, #8 428:	b2da      	uxtb	r2, r3 42a:	1c3b      	adds	r3, r7, #0 42c:	3344      	adds	r3, #68	; 0x44 42e:	711a      	strb	r2, [r3, #4]  data[5] = (-gyro_bias[2]/4)       & 0xFF; 430:	1c3b      	adds	r3, r7, #0 432:	3338      	adds	r3, #56	; 0x38 434:	689b      	ldr	r3, [r3, #8] 436:	425b      	negs	r3, r3 438:	2b00      	cmp	r3, #0 43a:	da00      	bge.n	43e <calibrateMPU9250+0x43e> 43c:	3303      	adds	r3, #3 43e:	109b      	asrs	r3, r3, #2 440:	b2da      	uxtb	r2, r3 442:	1c3b      	adds	r3, r7, #0 444:	3344      	adds	r3, #68	; 0x44 446:	715a      	strb	r2, [r3, #5]  // Push gyro biases to hardware registers  writeByte(MPU9250_ADDRESS, XG_OFFSET_H, data[0]); 448:	1c3b      	adds	r3, r7, #0 44a:	3344      	adds	r3, #68	; 0x44 44c:	781b      	ldrb	r3, [r3, #0] 44e:	2068      	movs	r0, #104	; 0x68 450:	2113      	movs	r1, #19 452:	1c1a      	adds	r2, r3, #0 454:	f7ff fffe 	bl	0 <writeByte>			454: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, XG_OFFSET_L, data[1]); 458:	1c3b      	adds	r3, r7, #0 45a:	3344      	adds	r3, #68	; 0x44 45c:	785b      	ldrb	r3, [r3, #1] 45e:	2068      	movs	r0, #104	; 0x68 460:	2114      	movs	r1, #20 462:	1c1a      	adds	r2, r3, #0 464:	f7ff fffe 	bl	0 <writeByte>			464: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, YG_OFFSET_H, data[2]); 468:	1c3b      	adds	r3, r7, #0 46a:	3344      	adds	r3, #68	; 0x44 46c:	789b      	ldrb	r3, [r3, #2] 46e:	2068      	movs	r0, #104	; 0x68 470:	2115      	movs	r1, #21 472:	1c1a      	adds	r2, r3, #0 474:	f7ff fffe 	bl	0 <writeByte>			474: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, YG_OFFSET_L, data[3]); 478:	1c3b      	adds	r3, r7, #0 47a:	3344      	adds	r3, #68	; 0x44 47c:	78db      	ldrb	r3, [r3, #3] 47e:	2068      	movs	r0, #104	; 0x68 480:	2116      	movs	r1, #22 482:	1c1a      	adds	r2, r3, #0 484:	f7ff fffe 	bl	0 <writeByte>			484: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, ZG_OFFSET_H, data[4]); 488:	1c3b      	adds	r3, r7, #0 48a:	3344      	adds	r3, #68	; 0x44 48c:	791b      	ldrb	r3, [r3, #4] 48e:	2068      	movs	r0, #104	; 0x68 490:	2117      	movs	r1, #23 492:	1c1a      	adds	r2, r3, #0 494:	f7ff fffe 	bl	0 <writeByte>			494: R_ARM_THM_CALL	writeByte  writeByte(MPU9250_ADDRESS, ZG_OFFSET_L, data[5]); 498:	1c3b      	adds	r3, r7, #0 49a:	3344      	adds	r3, #68	; 0x44 49c:	795b      	ldrb	r3, [r3, #5] 49e:	2068      	movs	r0, #104	; 0x68 4a0:	2118      	movs	r1, #24 4a2:	1c1a      	adds	r2, r3, #0 4a4:	f7ff fffe 	bl	0 <writeByte>			4a4: R_ARM_THM_CALL	writeByte  // Output scaled gyro biases for display in the main program  dest1[0] = (float) gyro_bias[0]/(float) gyrosensitivity;   4a8:	1c3b      	adds	r3, r7, #0 4aa:	3338      	adds	r3, #56	; 0x38 4ac:	681b      	ldr	r3, [r3, #0] 4ae:	1c18      	adds	r0, r3, #0 4b0:	f7ff fffe 	bl	0 <__aeabi_i2f>			4b0: R_ARM_THM_CALL	__aeabi_i2f 4b4:	1c04      	adds	r4, r0, #0 4b6:	1c3b      	adds	r3, r7, #0 4b8:	335c      	adds	r3, #92	; 0x5c 4ba:	881b      	ldrh	r3, [r3, #0] 4bc:	1c18      	adds	r0, r3, #0 4be:	f7ff fffe 	bl	0 <__aeabi_ui2f>			4be: R_ARM_THM_CALL	__aeabi_ui2f 4c2:	1c03      	adds	r3, r0, #0 4c4:	1c20      	adds	r0, r4, #0 4c6:	1c19      	adds	r1, r3, #0 4c8:	f7ff fffe 	bl	0 <__aeabi_fdiv>			4c8: R_ARM_THM_CALL	__aeabi_fdiv 4cc:	1c03      	adds	r3, r0, #0 4ce:	1c1a      	adds	r2, r3, #0 4d0:	687b      	ldr	r3, [r7, #4] 4d2:	601a      	str	r2, [r3, #0]  dest1[1] = (float) gyro_bias[1]/(float) gyrosensitivity; 4d4:	687b      	ldr	r3, [r7, #4] 4d6:	1d1c      	adds	r4, r3, #4 4d8:	1c3b      	adds	r3, r7, #0 4da:	3338      	adds	r3, #56	; 0x38 4dc:	685b      	ldr	r3, [r3, #4] 4de:	1c18      	adds	r0, r3, #0 4e0:	f7ff fffe 	bl	0 <__aeabi_i2f>			4e0: R_ARM_THM_CALL	__aeabi_i2f 4e4:	1c05      	adds	r5, r0, #0 4e6:	1c3b      	adds	r3, r7, #0 4e8:	335c      	adds	r3, #92	; 0x5c 4ea:	881b      	ldrh	r3, [r3, #0] 4ec:	1c18      	adds	r0, r3, #0 4ee:	f7ff fffe 	bl	0 <__aeabi_ui2f>			4ee: R_ARM_THM_CALL	__aeabi_ui2f 4f2:	1c03      	adds	r3, r0, #0 4f4:	1c28      	adds	r0, r5, #0 4f6:	1c19      	adds	r1, r3, #0 4f8:	f7ff fffe 	bl	0 <__aeabi_fdiv>			4f8: R_ARM_THM_CALL	__aeabi_fdiv 4fc:	1c03      	adds	r3, r0, #0 4fe:	6023      	str	r3, [r4, #0]  dest1[2] = (float) gyro_bias[2]/(float) gyrosensitivity; 500:	687b      	ldr	r3, [r7, #4] 502:	1c1c      	adds	r4, r3, #0 504:	3408      	adds	r4, #8 506:	1c3b      	adds	r3, r7, #0 508:	3338      	adds	r3, #56	; 0x38 50a:	689b      	ldr	r3, [r3, #8] 50c:	1c18      	adds	r0, r3, #0 50e:	f7ff fffe 	bl	0 <__aeabi_i2f>			50e: R_ARM_THM_CALL	__aeabi_i2f 512:	1c05      	adds	r5, r0, #0 514:	1c3b      	adds	r3, r7, #0 516:	335c      	adds	r3, #92	; 0x5c 518:	881b      	ldrh	r3, [r3, #0] 51a:	1c18      	adds	r0, r3, #0 51c:	f7ff fffe 	bl	0 <__aeabi_ui2f>			51c: R_ARM_THM_CALL	__aeabi_ui2f 520:	1c03      	adds	r3, r0, #0 522:	1c28      	adds	r0, r5, #0 524:	1c19      	adds	r1, r3, #0 526:	f7ff fffe 	bl	0 <__aeabi_fdiv>			526: R_ARM_THM_CALL	__aeabi_fdiv 52a:	1c03      	adds	r3, r0, #0 52c:	6023      	str	r3, [r4, #0]// factory trim values which must be added to the calculated accelerometer biases; on boot up these registers will hold// non-zero values. In addition, bit 0 of the lower byte must be preserved since it is used for temperature// compensation calculations. Accelerometer bias registers expect bias input as 2048 LSB per g, so that// the accelerometer biases calculated above must be divided by 8.  int32_t accel_bias_reg[3] = {0, 0, 0}; // A place to hold the factory accelerometer trim biases 52e:	1c3b      	adds	r3, r7, #0 530:	3320      	adds	r3, #32 532:	2200      	movs	r2, #0 534:	601a      	str	r2, [r3, #0] 536:	1c3b      	adds	r3, r7, #0 538:	3320      	adds	r3, #32 53a:	2200      	movs	r2, #0 53c:	605a      	str	r2, [r3, #4] 53e:	1c3b      	adds	r3, r7, #0 540:	3320      	adds	r3, #32 542:	2200      	movs	r2, #0 544:	609a      	str	r2, [r3, #8]  readBytes(MPU9250_ADDRESS, XA_OFFSET_H, 2, &data[0]); // Read factory accelerometer trim values 546:	1c3b      	adds	r3, r7, #0 548:	3344      	adds	r3, #68	; 0x44 54a:	2068      	movs	r0, #104	; 0x68 54c:	2177      	movs	r1, #119	; 0x77 54e:	2202      	movs	r2, #2 550:	f7ff fffe 	bl	0 <readBytes>			550: R_ARM_THM_CALL	readBytes  accel_bias_reg[0] = (int32_t) (((int16_t)data[0] << 8) | data[1]); 554:	1c3b      	adds	r3, r7, #0 556:	3344      	adds	r3, #68	; 0x44 558:	781b      	ldrb	r3, [r3, #0] 55a:	021a      	lsls	r2, r3, #8 55c:	1c3b      	adds	r3, r7, #0 55e:	3344      	adds	r3, #68	; 0x44 560:	785b      	ldrb	r3, [r3, #1] 562:	431a      	orrs	r2, r3 564:	1c3b      	adds	r3, r7, #0 566:	3320      	adds	r3, #32 568:	601a      	str	r2, [r3, #0]  readBytes(MPU9250_ADDRESS, YA_OFFSET_H, 2, &data[0]); 56a:	1c3b      	adds	r3, r7, #0 56c:	3344      	adds	r3, #68	; 0x44 56e:	2068      	movs	r0, #104	; 0x68 570:	217a      	movs	r1, #122	; 0x7a 572:	2202      	movs	r2, #2 574:	f7ff fffe 	bl	0 <readBytes>			574: R_ARM_THM_CALL	readBytes  accel_bias_reg[1] = (int32_t) (((int16_t)data[0] << 8) | data[1]); 578:	1c3b      	adds	r3, r7, #0 57a:	3344      	adds	r3, #68	; 0x44 57c:	781b      	ldrb	r3, [r3, #0] 57e:	021a      	lsls	r2, r3, #8 580:	1c3b      	adds	r3, r7, #0 582:	3344      	adds	r3, #68	; 0x44 584:	785b      	ldrb	r3, [r3, #1] 586:	431a      	orrs	r2, r3 588:	1c3b      	adds	r3, r7, #0 58a:	3320      	adds	r3, #32 58c:	605a      	str	r2, [r3, #4]  readBytes(MPU9250_ADDRESS, ZA_OFFSET_H, 2, &data[0]); 58e:	1c3b      	adds	r3, r7, #0 590:	3344      	adds	r3, #68	; 0x44 592:	2068      	movs	r0, #104	; 0x68 594:	217d      	movs	r1, #125	; 0x7d 596:	2202      	movs	r2, #2 598:	f7ff fffe 	bl	0 <readBytes>			598: R_ARM_THM_CALL	readBytes  accel_bias_reg[2] = (int32_t) (((int16_t)data[0] << 8) | data[1]); 59c:	1c3b      	adds	r3, r7, #0 59e:	3344      	adds	r3, #68	; 0x44 5a0:	781b      	ldrb	r3, [r3, #0] 5a2:	021a      	lsls	r2, r3, #8 5a4:	1c3b      	adds	r3, r7, #0 5a6:	3344      	adds	r3, #68	; 0x44 5a8:	785b      	ldrb	r3, [r3, #1] 5aa:	431a      	orrs	r2, r3 5ac:	1c3b      	adds	r3, r7, #0 5ae:	3320      	adds	r3, #32 5b0:	609a      	str	r2, [r3, #8]    uint32_t mask = 1uL; // Define mask for temperature compensation bit 0 of lower byte of accelerometer bias registers 5b2:	2301      	movs	r3, #1 5b4:	653b      	str	r3, [r7, #80]	; 0x50  uint8_t mask_bit[3] = {0, 0, 0}; // Define array to hold mask bit for each accelerometer bias axis 5b6:	1c3b      	adds	r3, r7, #0 5b8:	331c      	adds	r3, #28 5ba:	2200      	movs	r2, #0 5bc:	701a      	strb	r2, [r3, #0] 5be:	1c3b      	adds	r3, r7, #0 5c0:	331c      	adds	r3, #28 5c2:	2200      	movs	r2, #0 5c4:	705a      	strb	r2, [r3, #1] 5c6:	1c3b      	adds	r3, r7, #0 5c8:	331c      	adds	r3, #28 5ca:	2200      	movs	r2, #0 5cc:	709a      	strb	r2, [r3, #2]    for(ii = 0; ii < 3; ii++) { 5ce:	1c3b      	adds	r3, r7, #0 5d0:	335e      	adds	r3, #94	; 0x5e 5d2:	2200      	movs	r2, #0 5d4:	801a      	strh	r2, [r3, #0] 5d6:	e017      	b.n	608 <calibrateMPU9250+0x608>    if((accel_bias_reg[ii] & mask)) mask_bit[ii] = 0x01; // If temperature compensation bit is set, record that fact in mask_bit 5d8:	1c3b      	adds	r3, r7, #0 5da:	335e      	adds	r3, #94	; 0x5e 5dc:	881a      	ldrh	r2, [r3, #0] 5de:	1c3b      	adds	r3, r7, #0 5e0:	3320      	adds	r3, #32 5e2:	0092      	lsls	r2, r2, #2 5e4:	58d3      	ldr	r3, [r2, r3] 5e6:	6d3a      	ldr	r2, [r7, #80]	; 0x50 5e8:	4013      	ands	r3, r2 5ea:	d006      	beq.n	5fa <calibrateMPU9250+0x5fa> 5ec:	1c3b      	adds	r3, r7, #0 5ee:	335e      	adds	r3, #94	; 0x5e 5f0:	881b      	ldrh	r3, [r3, #0] 5f2:	1c3a      	adds	r2, r7, #0 5f4:	321c      	adds	r2, #28 5f6:	2101      	movs	r1, #1 5f8:	54d1      	strb	r1, [r2, r3]  accel_bias_reg[2] = (int32_t) (((int16_t)data[0] << 8) | data[1]);    uint32_t mask = 1uL; // Define mask for temperature compensation bit 0 of lower byte of accelerometer bias registers  uint8_t mask_bit[3] = {0, 0, 0}; // Define array to hold mask bit for each accelerometer bias axis    for(ii = 0; ii < 3; ii++) { 5fa:	1c3b      	adds	r3, r7, #0 5fc:	335e      	adds	r3, #94	; 0x5e 5fe:	1c3a      	adds	r2, r7, #0 600:	325e      	adds	r2, #94	; 0x5e 602:	8812      	ldrh	r2, [r2, #0] 604:	3201      	adds	r2, #1 606:	801a      	strh	r2, [r3, #0] 608:	1c3b      	adds	r3, r7, #0 60a:	335e      	adds	r3, #94	; 0x5e 60c:	881b      	ldrh	r3, [r3, #0] 60e:	2b02      	cmp	r3, #2 610:	d9e2      	bls.n	5d8 <calibrateMPU9250+0x5d8>    if((accel_bias_reg[ii] & mask)) mask_bit[ii] = 0x01; // If temperature compensation bit is set, record that fact in mask_bit  }    // Construct total accelerometer bias, including calculated average accelerometer bias from above  accel_bias_reg[0] -= (accel_bias[0]/8); // Subtract calculated averaged accelerometer bias scaled to 2048 LSB/g (16 g full scale) 612:	1c3b      	adds	r3, r7, #0 614:	3320      	adds	r3, #32 616:	681a      	ldr	r2, [r3, #0] 618:	1c3b      	adds	r3, r7, #0 61a:	332c      	adds	r3, #44	; 0x2c 61c:	681b      	ldr	r3, [r3, #0] 61e:	2b00      	cmp	r3, #0 620:	da00      	bge.n	624 <calibrateMPU9250+0x624> 622:	3307      	adds	r3, #7 624:	10db      	asrs	r3, r3, #3 626:	1ad2      	subs	r2, r2, r3 628:	1c3b      	adds	r3, r7, #0 62a:	3320      	adds	r3, #32 62c:	601a      	str	r2, [r3, #0]  accel_bias_reg[1] -= (accel_bias[1]/8); 62e:	1c3b      	adds	r3, r7, #0 630:	3320      	adds	r3, #32 632:	685a      	ldr	r2, [r3, #4] 634:	1c3b      	adds	r3, r7, #0 636:	332c      	adds	r3, #44	; 0x2c 638:	685b      	ldr	r3, [r3, #4] 63a:	2b00      	cmp	r3, #0 63c:	da00      	bge.n	640 <calibrateMPU9250+0x640> 63e:	3307      	adds	r3, #7 640:	10db      	asrs	r3, r3, #3 642:	1ad2      	subs	r2, r2, r3 644:	1c3b      	adds	r3, r7, #0 646:	3320      	adds	r3, #32 648:	605a      	str	r2, [r3, #4]  accel_bias_reg[2] -= (accel_bias[2]/8); 64a:	1c3b      	adds	r3, r7, #0 64c:	3320      	adds	r3, #32 64e:	689a      	ldr	r2, [r3, #8] 650:	1c3b      	adds	r3, r7, #0 652:	332c      	adds	r3, #44	; 0x2c 654:	689b      	ldr	r3, [r3, #8] 656:	2b00      	cmp	r3, #0 658:	da00      	bge.n	65c <calibrateMPU9250+0x65c> 65a:	3307      	adds	r3, #7 65c:	10db      	asrs	r3, r3, #3 65e:	1ad2      	subs	r2, r2, r3 660:	1c3b      	adds	r3, r7, #0 662:	3320      	adds	r3, #32 664:	609a      	str	r2, [r3, #8]    data[0] = (accel_bias_reg[0] >> 8) & 0xFF; 666:	1c3b      	adds	r3, r7, #0 668:	3320      	adds	r3, #32 66a:	681b      	ldr	r3, [r3, #0] 66c:	121b      	asrs	r3, r3, #8 66e:	b2da      	uxtb	r2, r3 670:	1c3b      	adds	r3, r7, #0 672:	3344      	adds	r3, #68	; 0x44 674:	701a      	strb	r2, [r3, #0]  data[1] = (accel_bias_reg[0])      & 0xFF; 676:	1c3b      	adds	r3, r7, #0 678:	3320      	adds	r3, #32 67a:	681b      	ldr	r3, [r3, #0] 67c:	b2da      	uxtb	r2, r3 67e:	1c3b      	adds	r3, r7, #0 680:	3344      	adds	r3, #68	; 0x44 682:	705a      	strb	r2, [r3, #1]  data[1] = data[1] | mask_bit[0]; // preserve temperature compensation bit when writing back to accelerometer bias registers 684:	1c3b      	adds	r3, r7, #0 686:	3344      	adds	r3, #68	; 0x44 688:	785a      	ldrb	r2, [r3, #1] 68a:	1c3b      	adds	r3, r7, #0 68c:	331c      	adds	r3, #28 68e:	781b      	ldrb	r3, [r3, #0] 690:	4313      	orrs	r3, r2 692:	b2da      	uxtb	r2, r3 694:	1c3b      	adds	r3, r7, #0 696:	3344      	adds	r3, #68	; 0x44 698:	705a      	strb	r2, [r3, #1]  data[2] = (accel_bias_reg[1] >> 8) & 0xFF; 69a:	1c3b      	adds	r3, r7, #0 69c:	3320      	adds	r3, #32 69e:	685b      	ldr	r3, [r3, #4] 6a0:	121b      	asrs	r3, r3, #8 6a2:	b2da      	uxtb	r2, r3 6a4:	1c3b      	adds	r3, r7, #0 6a6:	3344      	adds	r3, #68	; 0x44 6a8:	709a      	strb	r2, [r3, #2]  data[3] = (accel_bias_reg[1])      & 0xFF; 6aa:	1c3b      	adds	r3, r7, #0 6ac:	3320      	adds	r3, #32 6ae:	685b      	ldr	r3, [r3, #4] 6b0:	b2da      	uxtb	r2, r3 6b2:	1c3b      	adds	r3, r7, #0 6b4:	3344      	adds	r3, #68	; 0x44 6b6:	70da      	strb	r2, [r3, #3]  data[3] = data[3] | mask_bit[1]; // preserve temperature compensation bit when writing back to accelerometer bias registers 6b8:	1c3b      	adds	r3, r7, #0 6ba:	3344      	adds	r3, #68	; 0x44 6bc:	78da      	ldrb	r2, [r3, #3] 6be:	1c3b      	adds	r3, r7, #0 6c0:	331c      	adds	r3, #28 6c2:	785b      	ldrb	r3, [r3, #1] 6c4:	4313      	orrs	r3, r2 6c6:	b2da      	uxtb	r2, r3 6c8:	1c3b      	adds	r3, r7, #0 6ca:	3344      	adds	r3, #68	; 0x44 6cc:	70da      	strb	r2, [r3, #3]  data[4] = (accel_bias_reg[2] >> 8) & 0xFF; 6ce:	1c3b      	adds	r3, r7, #0 6d0:	3320      	adds	r3, #32 6d2:	689b      	ldr	r3, [r3, #8] 6d4:	121b      	asrs	r3, r3, #8 6d6:	b2da      	uxtb	r2, r3 6d8:	1c3b      	adds	r3, r7, #0 6da:	3344      	adds	r3, #68	; 0x44 6dc:	711a      	strb	r2, [r3, #4]  data[5] = (accel_bias_reg[2])      & 0xFF; 6de:	1c3b      	adds	r3, r7, #0 6e0:	3320      	adds	r3, #32 6e2:	689b      	ldr	r3, [r3, #8] 6e4:	b2da      	uxtb	r2, r3 6e6:	1c3b      	adds	r3, r7, #0 6e8:	3344      	adds	r3, #68	; 0x44 6ea:	715a      	strb	r2, [r3, #5]  data[5] = data[5] | mask_bit[2]; // preserve temperature compensation bit when writing back to accelerometer bias registers 6ec:	1c3b      	adds	r3, r7, #0 6ee:	3344      	adds	r3, #68	; 0x44 6f0:	795a      	ldrb	r2, [r3, #5] 6f2:	1c3b      	adds	r3, r7, #0 6f4:	331c      	adds	r3, #28 6f6:	789b      	ldrb	r3, [r3, #2] 6f8:	4313      	orrs	r3, r2 6fa:	b2da      	uxtb	r2, r3 6fc:	1c3b      	adds	r3, r7, #0 6fe:	3344      	adds	r3, #68	; 0x44 700:	715a      	strb	r2, [r3, #5]//  writeByte(MPU9250_ADDRESS, YA_OFFSET_L, data[3]);//  writeByte(MPU9250_ADDRESS, ZA_OFFSET_H, data[4]);//  writeByte(MPU9250_ADDRESS, ZA_OFFSET_L, data[5]);// Output scaled accelerometer biases for display in the main program   dest2[0] = (float)accel_bias[0]/(float)accelsensitivity;  702:	1c3b      	adds	r3, r7, #0 704:	332c      	adds	r3, #44	; 0x2c 706:	681b      	ldr	r3, [r3, #0] 708:	1c18      	adds	r0, r3, #0 70a:	f7ff fffe 	bl	0 <__aeabi_i2f>			70a: R_ARM_THM_CALL	__aeabi_i2f 70e:	1c04      	adds	r4, r0, #0 710:	1c3b      	adds	r3, r7, #0 712:	335a      	adds	r3, #90	; 0x5a 714:	881b      	ldrh	r3, [r3, #0] 716:	1c18      	adds	r0, r3, #0 718:	f7ff fffe 	bl	0 <__aeabi_ui2f>			718: R_ARM_THM_CALL	__aeabi_ui2f 71c:	1c03      	adds	r3, r0, #0 71e:	1c20      	adds	r0, r4, #0 720:	1c19      	adds	r1, r3, #0 722:	f7ff fffe 	bl	0 <__aeabi_fdiv>			722: R_ARM_THM_CALL	__aeabi_fdiv 726:	1c03      	adds	r3, r0, #0 728:	1c1a      	adds	r2, r3, #0 72a:	683b      	ldr	r3, [r7, #0] 72c:	601a      	str	r2, [r3, #0]   dest2[1] = (float)accel_bias[1]/(float)accelsensitivity; 72e:	683b      	ldr	r3, [r7, #0] 730:	1d1c      	adds	r4, r3, #4 732:	1c3b      	adds	r3, r7, #0 734:	332c      	adds	r3, #44	; 0x2c 736:	685b      	ldr	r3, [r3, #4] 738:	1c18      	adds	r0, r3, #0 73a:	f7ff fffe 	bl	0 <__aeabi_i2f>			73a: R_ARM_THM_CALL	__aeabi_i2f 73e:	1c05      	adds	r5, r0, #0 740:	1c3b      	adds	r3, r7, #0 742:	335a      	adds	r3, #90	; 0x5a 744:	881b      	ldrh	r3, [r3, #0] 746:	1c18      	adds	r0, r3, #0 748:	f7ff fffe 	bl	0 <__aeabi_ui2f>			748: R_ARM_THM_CALL	__aeabi_ui2f 74c:	1c03      	adds	r3, r0, #0 74e:	1c28      	adds	r0, r5, #0 750:	1c19      	adds	r1, r3, #0 752:	f7ff fffe 	bl	0 <__aeabi_fdiv>			752: R_ARM_THM_CALL	__aeabi_fdiv 756:	1c03      	adds	r3, r0, #0 758:	6023      	str	r3, [r4, #0]   dest2[2] = (float)accel_bias[2]/(float)accelsensitivity; 75a:	683b      	ldr	r3, [r7, #0] 75c:	1c1c      	adds	r4, r3, #0 75e:	3408      	adds	r4, #8 760:	1c3b      	adds	r3, r7, #0 762:	332c      	adds	r3, #44	; 0x2c 764:	689b      	ldr	r3, [r3, #8] 766:	1c18      	adds	r0, r3, #0 768:	f7ff fffe 	bl	0 <__aeabi_i2f>			768: R_ARM_THM_CALL	__aeabi_i2f 76c:	1c05      	adds	r5, r0, #0 76e:	1c3b      	adds	r3, r7, #0 770:	335a      	adds	r3, #90	; 0x5a 772:	881b      	ldrh	r3, [r3, #0] 774:	1c18      	adds	r0, r3, #0 776:	f7ff fffe 	bl	0 <__aeabi_ui2f>			776: R_ARM_THM_CALL	__aeabi_ui2f 77a:	1c03      	adds	r3, r0, #0 77c:	1c28      	adds	r0, r5, #0 77e:	1c19      	adds	r1, r3, #0 780:	f7ff fffe 	bl	0 <__aeabi_fdiv>			780: R_ARM_THM_CALL	__aeabi_fdiv 784:	1c03      	adds	r3, r0, #0 786:	6023      	str	r3, [r4, #0]} 788:	46bd      	mov	sp, r7 78a:	b018      	add	sp, #96	; 0x60 78c:	bdb0      	pop	{r4, r5, r7, pc} 78e:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.readData:00000000 <readData>:void readData(){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0	 readGyroData(mpu9250.gyroCount);   4:	4b97      	ldr	r3, [pc, #604]	; (264 <readData+0x264>)   6:	1c18      	adds	r0, r3, #0   8:	f7ff fffe 	bl	0 <readData>			8: R_ARM_THM_CALL	readGyroData		 mpu9250.gx = (float)mpu9250.gyroCount[0]*mpu9250.gRes - mpu9250.gyroBias[0];  // get actual gyro value, this depends on scale being set   c:	4b96      	ldr	r3, [pc, #600]	; (268 <readData+0x268>)   e:	8f1b      	ldrh	r3, [r3, #56]	; 0x38  10:	b21b      	sxth	r3, r3  12:	1c18      	adds	r0, r3, #0  14:	f7ff fffe 	bl	0 <__aeabi_i2f>			14: R_ARM_THM_CALL	__aeabi_i2f  18:	1c02      	adds	r2, r0, #0  1a:	4b93      	ldr	r3, [pc, #588]	; (268 <readData+0x268>)  1c:	6c9b      	ldr	r3, [r3, #72]	; 0x48  1e:	1c10      	adds	r0, r2, #0  20:	1c19      	adds	r1, r3, #0  22:	f7ff fffe 	bl	0 <__aeabi_fmul>			22: R_ARM_THM_CALL	__aeabi_fmul  26:	1c03      	adds	r3, r0, #0  28:	1c1a      	adds	r2, r3, #0  2a:	498f      	ldr	r1, [pc, #572]	; (268 <readData+0x268>)  2c:	238c      	movs	r3, #140	; 0x8c  2e:	58cb      	ldr	r3, [r1, r3]  30:	1c10      	adds	r0, r2, #0  32:	1c19      	adds	r1, r3, #0  34:	f7ff fffe 	bl	0 <__aeabi_fsub>			34: R_ARM_THM_CALL	__aeabi_fsub  38:	1c03      	adds	r3, r0, #0  3a:	1c1a      	adds	r2, r3, #0  3c:	4b8a      	ldr	r3, [pc, #552]	; (268 <readData+0x268>)  3e:	65da      	str	r2, [r3, #92]	; 0x5c		 mpu9250.gy = (float)mpu9250.gyroCount[1]*mpu9250.gRes - mpu9250.gyroBias[1];    40:	4b89      	ldr	r3, [pc, #548]	; (268 <readData+0x268>)  42:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a  44:	b21b      	sxth	r3, r3  46:	1c18      	adds	r0, r3, #0  48:	f7ff fffe 	bl	0 <__aeabi_i2f>			48: R_ARM_THM_CALL	__aeabi_i2f  4c:	1c02      	adds	r2, r0, #0  4e:	4b86      	ldr	r3, [pc, #536]	; (268 <readData+0x268>)  50:	6c9b      	ldr	r3, [r3, #72]	; 0x48  52:	1c10      	adds	r0, r2, #0  54:	1c19      	adds	r1, r3, #0  56:	f7ff fffe 	bl	0 <__aeabi_fmul>			56: R_ARM_THM_CALL	__aeabi_fmul  5a:	1c03      	adds	r3, r0, #0  5c:	1c1a      	adds	r2, r3, #0  5e:	4982      	ldr	r1, [pc, #520]	; (268 <readData+0x268>)  60:	2390      	movs	r3, #144	; 0x90  62:	58cb      	ldr	r3, [r1, r3]  64:	1c10      	adds	r0, r2, #0  66:	1c19      	adds	r1, r3, #0  68:	f7ff fffe 	bl	0 <__aeabi_fsub>			68: R_ARM_THM_CALL	__aeabi_fsub  6c:	1c03      	adds	r3, r0, #0  6e:	1c1a      	adds	r2, r3, #0  70:	4b7d      	ldr	r3, [pc, #500]	; (268 <readData+0x268>)  72:	661a      	str	r2, [r3, #96]	; 0x60		 mpu9250.gz = (float)mpu9250.gyroCount[2]*mpu9250.gRes - mpu9250.gyroBias[2];     74:	4b7c      	ldr	r3, [pc, #496]	; (268 <readData+0x268>)  76:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c  78:	b21b      	sxth	r3, r3  7a:	1c18      	adds	r0, r3, #0  7c:	f7ff fffe 	bl	0 <__aeabi_i2f>			7c: R_ARM_THM_CALL	__aeabi_i2f  80:	1c02      	adds	r2, r0, #0  82:	4b79      	ldr	r3, [pc, #484]	; (268 <readData+0x268>)  84:	6c9b      	ldr	r3, [r3, #72]	; 0x48  86:	1c10      	adds	r0, r2, #0  88:	1c19      	adds	r1, r3, #0  8a:	f7ff fffe 	bl	0 <__aeabi_fmul>			8a: R_ARM_THM_CALL	__aeabi_fmul  8e:	1c03      	adds	r3, r0, #0  90:	1c1a      	adds	r2, r3, #0  92:	4975      	ldr	r1, [pc, #468]	; (268 <readData+0x268>)  94:	2394      	movs	r3, #148	; 0x94  96:	58cb      	ldr	r3, [r1, r3]  98:	1c10      	adds	r0, r2, #0  9a:	1c19      	adds	r1, r3, #0  9c:	f7ff fffe 	bl	0 <__aeabi_fsub>			9c: R_ARM_THM_CALL	__aeabi_fsub  a0:	1c03      	adds	r3, r0, #0  a2:	1c1a      	adds	r2, r3, #0  a4:	4b70      	ldr	r3, [pc, #448]	; (268 <readData+0x268>)  a6:	665a      	str	r2, [r3, #100]	; 0x64		 readMagData(mpu9250.magCount);  a8:	4b70      	ldr	r3, [pc, #448]	; (26c <readData+0x26c>)  aa:	1c18      	adds	r0, r3, #0  ac:	f7ff fffe 	bl	0 <readData>			ac: R_ARM_THM_CALL	readMagData		 mpu9250.mx = (float)mpu9250.magCount[0]*mpu9250.mRes*mpu9250.magCalibration[0] - mpu9250.magbias[0];  // get actual magnetometer value, this depends on scale being set  b0:	4b6d      	ldr	r3, [pc, #436]	; (268 <readData+0x268>)  b2:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e  b4:	b21b      	sxth	r3, r3  b6:	1c18      	adds	r0, r3, #0  b8:	f7ff fffe 	bl	0 <__aeabi_i2f>			b8: R_ARM_THM_CALL	__aeabi_i2f  bc:	1c02      	adds	r2, r0, #0  be:	4b6a      	ldr	r3, [pc, #424]	; (268 <readData+0x268>)  c0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c  c2:	1c10      	adds	r0, r2, #0  c4:	1c19      	adds	r1, r3, #0  c6:	f7ff fffe 	bl	0 <__aeabi_fmul>			c6: R_ARM_THM_CALL	__aeabi_fmul  ca:	1c03      	adds	r3, r0, #0  cc:	1c1a      	adds	r2, r3, #0  ce:	4b66      	ldr	r3, [pc, #408]	; (268 <readData+0x268>)  d0:	6f5b      	ldr	r3, [r3, #116]	; 0x74  d2:	1c10      	adds	r0, r2, #0  d4:	1c19      	adds	r1, r3, #0  d6:	f7ff fffe 	bl	0 <__aeabi_fmul>			d6: R_ARM_THM_CALL	__aeabi_fmul  da:	1c03      	adds	r3, r0, #0  dc:	1c1a      	adds	r2, r3, #0  de:	4962      	ldr	r1, [pc, #392]	; (268 <readData+0x268>)  e0:	2380      	movs	r3, #128	; 0x80  e2:	58cb      	ldr	r3, [r1, r3]  e4:	1c10      	adds	r0, r2, #0  e6:	1c19      	adds	r1, r3, #0  e8:	f7ff fffe 	bl	0 <__aeabi_fsub>			e8: R_ARM_THM_CALL	__aeabi_fsub  ec:	1c03      	adds	r3, r0, #0  ee:	1c1a      	adds	r2, r3, #0  f0:	4b5d      	ldr	r3, [pc, #372]	; (268 <readData+0x268>)  f2:	669a      	str	r2, [r3, #104]	; 0x68		 mpu9250.my = (float)mpu9250.magCount[1]*mpu9250.mRes*mpu9250.magCalibration[1] - mpu9250.magbias[1];    f4:	4a5c      	ldr	r2, [pc, #368]	; (268 <readData+0x268>)  f6:	2340      	movs	r3, #64	; 0x40  f8:	5ad3      	ldrh	r3, [r2, r3]  fa:	b21b      	sxth	r3, r3  fc:	1c18      	adds	r0, r3, #0  fe:	f7ff fffe 	bl	0 <__aeabi_i2f>			fe: R_ARM_THM_CALL	__aeabi_i2f 102:	1c02      	adds	r2, r0, #0 104:	4b58      	ldr	r3, [pc, #352]	; (268 <readData+0x268>) 106:	6cdb      	ldr	r3, [r3, #76]	; 0x4c 108:	1c10      	adds	r0, r2, #0 10a:	1c19      	adds	r1, r3, #0 10c:	f7ff fffe 	bl	0 <__aeabi_fmul>			10c: R_ARM_THM_CALL	__aeabi_fmul 110:	1c03      	adds	r3, r0, #0 112:	1c1a      	adds	r2, r3, #0 114:	4b54      	ldr	r3, [pc, #336]	; (268 <readData+0x268>) 116:	6f9b      	ldr	r3, [r3, #120]	; 0x78 118:	1c10      	adds	r0, r2, #0 11a:	1c19      	adds	r1, r3, #0 11c:	f7ff fffe 	bl	0 <__aeabi_fmul>			11c: R_ARM_THM_CALL	__aeabi_fmul 120:	1c03      	adds	r3, r0, #0 122:	1c1a      	adds	r2, r3, #0 124:	4950      	ldr	r1, [pc, #320]	; (268 <readData+0x268>) 126:	2384      	movs	r3, #132	; 0x84 128:	58cb      	ldr	r3, [r1, r3] 12a:	1c10      	adds	r0, r2, #0 12c:	1c19      	adds	r1, r3, #0 12e:	f7ff fffe 	bl	0 <__aeabi_fsub>			12e: R_ARM_THM_CALL	__aeabi_fsub 132:	1c03      	adds	r3, r0, #0 134:	1c1a      	adds	r2, r3, #0 136:	4b4c      	ldr	r3, [pc, #304]	; (268 <readData+0x268>) 138:	66da      	str	r2, [r3, #108]	; 0x6c		 mpu9250.mz = (float)mpu9250.magCount[2]*mpu9250.mRes*mpu9250.magCalibration[2] - mpu9250.magbias[2];  13a:	4a4b      	ldr	r2, [pc, #300]	; (268 <readData+0x268>) 13c:	2342      	movs	r3, #66	; 0x42 13e:	5ad3      	ldrh	r3, [r2, r3] 140:	b21b      	sxth	r3, r3 142:	1c18      	adds	r0, r3, #0 144:	f7ff fffe 	bl	0 <__aeabi_i2f>			144: R_ARM_THM_CALL	__aeabi_i2f 148:	1c02      	adds	r2, r0, #0 14a:	4b47      	ldr	r3, [pc, #284]	; (268 <readData+0x268>) 14c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c 14e:	1c10      	adds	r0, r2, #0 150:	1c19      	adds	r1, r3, #0 152:	f7ff fffe 	bl	0 <__aeabi_fmul>			152: R_ARM_THM_CALL	__aeabi_fmul 156:	1c03      	adds	r3, r0, #0 158:	1c1a      	adds	r2, r3, #0 15a:	4b43      	ldr	r3, [pc, #268]	; (268 <readData+0x268>) 15c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c 15e:	1c10      	adds	r0, r2, #0 160:	1c19      	adds	r1, r3, #0 162:	f7ff fffe 	bl	0 <__aeabi_fmul>			162: R_ARM_THM_CALL	__aeabi_fmul 166:	1c03      	adds	r3, r0, #0 168:	1c1a      	adds	r2, r3, #0 16a:	493f      	ldr	r1, [pc, #252]	; (268 <readData+0x268>) 16c:	2388      	movs	r3, #136	; 0x88 16e:	58cb      	ldr	r3, [r1, r3] 170:	1c10      	adds	r0, r2, #0 172:	1c19      	adds	r1, r3, #0 174:	f7ff fffe 	bl	0 <__aeabi_fsub>			174: R_ARM_THM_CALL	__aeabi_fsub 178:	1c03      	adds	r3, r0, #0 17a:	1c1a      	adds	r2, r3, #0 17c:	4b3a      	ldr	r3, [pc, #232]	; (268 <readData+0x268>) 17e:	671a      	str	r2, [r3, #112]	; 0x70		 readAccelData(mpu9250.accelCount); 180:	4b3b      	ldr	r3, [pc, #236]	; (270 <readData+0x270>) 182:	1c18      	adds	r0, r3, #0 184:	f7ff fffe 	bl	0 <readData>			184: R_ARM_THM_CALL	readAccelData		 mpu9250.ax = (float)mpu9250.accelCount[0]*mpu9250.aRes - mpu9250.accelBias[0];  // get actual g value, this depends on scale being set 188:	4a37      	ldr	r2, [pc, #220]	; (268 <readData+0x268>) 18a:	23bc      	movs	r3, #188	; 0xbc 18c:	5ad3      	ldrh	r3, [r2, r3] 18e:	b21b      	sxth	r3, r3 190:	1c18      	adds	r0, r3, #0 192:	f7ff fffe 	bl	0 <__aeabi_i2f>			192: R_ARM_THM_CALL	__aeabi_i2f 196:	1c02      	adds	r2, r0, #0 198:	4b33      	ldr	r3, [pc, #204]	; (268 <readData+0x268>) 19a:	6c5b      	ldr	r3, [r3, #68]	; 0x44 19c:	1c10      	adds	r0, r2, #0 19e:	1c19      	adds	r1, r3, #0 1a0:	f7ff fffe 	bl	0 <__aeabi_fmul>			1a0: R_ARM_THM_CALL	__aeabi_fmul 1a4:	1c03      	adds	r3, r0, #0 1a6:	1c1a      	adds	r2, r3, #0 1a8:	492f      	ldr	r1, [pc, #188]	; (268 <readData+0x268>) 1aa:	2398      	movs	r3, #152	; 0x98 1ac:	58cb      	ldr	r3, [r1, r3] 1ae:	1c10      	adds	r0, r2, #0 1b0:	1c19      	adds	r1, r3, #0 1b2:	f7ff fffe 	bl	0 <__aeabi_fsub>			1b2: R_ARM_THM_CALL	__aeabi_fsub 1b6:	1c03      	adds	r3, r0, #0 1b8:	1c1a      	adds	r2, r3, #0 1ba:	4b2b      	ldr	r3, [pc, #172]	; (268 <readData+0x268>) 1bc:	651a      	str	r2, [r3, #80]	; 0x50		 mpu9250.ay = (float)mpu9250.accelCount[1]*mpu9250.aRes - mpu9250.accelBias[1];    1be:	4a2a      	ldr	r2, [pc, #168]	; (268 <readData+0x268>) 1c0:	23be      	movs	r3, #190	; 0xbe 1c2:	5ad3      	ldrh	r3, [r2, r3] 1c4:	b21b      	sxth	r3, r3 1c6:	1c18      	adds	r0, r3, #0 1c8:	f7ff fffe 	bl	0 <__aeabi_i2f>			1c8: R_ARM_THM_CALL	__aeabi_i2f 1cc:	1c02      	adds	r2, r0, #0 1ce:	4b26      	ldr	r3, [pc, #152]	; (268 <readData+0x268>) 1d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44 1d2:	1c10      	adds	r0, r2, #0 1d4:	1c19      	adds	r1, r3, #0 1d6:	f7ff fffe 	bl	0 <__aeabi_fmul>			1d6: R_ARM_THM_CALL	__aeabi_fmul 1da:	1c03      	adds	r3, r0, #0 1dc:	1c1a      	adds	r2, r3, #0 1de:	4922      	ldr	r1, [pc, #136]	; (268 <readData+0x268>) 1e0:	239c      	movs	r3, #156	; 0x9c 1e2:	58cb      	ldr	r3, [r1, r3] 1e4:	1c10      	adds	r0, r2, #0 1e6:	1c19      	adds	r1, r3, #0 1e8:	f7ff fffe 	bl	0 <__aeabi_fsub>			1e8: R_ARM_THM_CALL	__aeabi_fsub 1ec:	1c03      	adds	r3, r0, #0 1ee:	1c1a      	adds	r2, r3, #0 1f0:	4b1d      	ldr	r3, [pc, #116]	; (268 <readData+0x268>) 1f2:	655a      	str	r2, [r3, #84]	; 0x54		 mpu9250.az = (float)mpu9250.accelCount[2]*mpu9250.aRes - mpu9250.accelBias[2];   1f4:	4a1c      	ldr	r2, [pc, #112]	; (268 <readData+0x268>) 1f6:	23c0      	movs	r3, #192	; 0xc0 1f8:	5ad3      	ldrh	r3, [r2, r3] 1fa:	b21b      	sxth	r3, r3 1fc:	1c18      	adds	r0, r3, #0 1fe:	f7ff fffe 	bl	0 <__aeabi_i2f>			1fe: R_ARM_THM_CALL	__aeabi_i2f 202:	1c02      	adds	r2, r0, #0 204:	4b18      	ldr	r3, [pc, #96]	; (268 <readData+0x268>) 206:	6c5b      	ldr	r3, [r3, #68]	; 0x44 208:	1c10      	adds	r0, r2, #0 20a:	1c19      	adds	r1, r3, #0 20c:	f7ff fffe 	bl	0 <__aeabi_fmul>			20c: R_ARM_THM_CALL	__aeabi_fmul 210:	1c03      	adds	r3, r0, #0 212:	1c1a      	adds	r2, r3, #0 214:	4914      	ldr	r1, [pc, #80]	; (268 <readData+0x268>) 216:	23a0      	movs	r3, #160	; 0xa0 218:	58cb      	ldr	r3, [r1, r3] 21a:	1c10      	adds	r0, r2, #0 21c:	1c19      	adds	r1, r3, #0 21e:	f7ff fffe 	bl	0 <__aeabi_fsub>			21e: R_ARM_THM_CALL	__aeabi_fsub 222:	1c03      	adds	r3, r0, #0 224:	1c1a      	adds	r2, r3, #0 226:	4b10      	ldr	r3, [pc, #64]	; (268 <readData+0x268>) 228:	659a      	str	r2, [r3, #88]	; 0x58		 mpu9250.tempCount= readTempData(); 22a:	f7ff fffe 	bl	0 <readData>			22a: R_ARM_THM_CALL	readTempData 22e:	1c03      	adds	r3, r0, #0 230:	1c1a      	adds	r2, r3, #0 232:	4b0d      	ldr	r3, [pc, #52]	; (268 <readData+0x268>) 234:	829a      	strh	r2, [r3, #20]		 mpu9250.temperature = ((float) mpu9250.tempCount) / 333.87f + 21.0f; // Temperature in degrees Centigrade 236:	4b0c      	ldr	r3, [pc, #48]	; (268 <readData+0x268>) 238:	8a9b      	ldrh	r3, [r3, #20] 23a:	b21b      	sxth	r3, r3 23c:	1c18      	adds	r0, r3, #0 23e:	f7ff fffe 	bl	0 <__aeabi_i2f>			23e: R_ARM_THM_CALL	__aeabi_i2f 242:	1c03      	adds	r3, r0, #0 244:	1c18      	adds	r0, r3, #0 246:	490b      	ldr	r1, [pc, #44]	; (274 <readData+0x274>) 248:	f7ff fffe 	bl	0 <__aeabi_fdiv>			248: R_ARM_THM_CALL	__aeabi_fdiv 24c:	1c03      	adds	r3, r0, #0 24e:	1c18      	adds	r0, r3, #0 250:	4909      	ldr	r1, [pc, #36]	; (278 <readData+0x278>) 252:	f7ff fffe 	bl	0 <__aeabi_fadd>			252: R_ARM_THM_CALL	__aeabi_fadd 256:	1c03      	adds	r3, r0, #0 258:	1c1a      	adds	r2, r3, #0 25a:	4b03      	ldr	r3, [pc, #12]	; (268 <readData+0x268>) 25c:	611a      	str	r2, [r3, #16]} 25e:	46bd      	mov	sp, r7 260:	bd80      	pop	{r7, pc} 262:	46c0      	nop			; (mov r8, r8) 264:	00000038 	.word	0x00000038			264: R_ARM_ABS32	mpu9250 268:	00000000 	.word	0x00000000			268: R_ARM_ABS32	mpu9250 26c:	0000003e 	.word	0x0000003e			26c: R_ARM_ABS32	mpu9250 270:	000000bc 	.word	0x000000bc			270: R_ARM_ABS32	mpu9250 274:	43a6ef5c 	.word	0x43a6ef5c 278:	41a80000 	.word	0x41a80000Disassembly of section .text.accelWakeOnMotion:00000000 <accelWakeOnMotion>:void accelWakeOnMotion(){   0:	b590      	push	{r4, r7, lr}   2:	b083      	sub	sp, #12   4:	af00      	add	r7, sp, #0  // Set accelerometer sample rate configuration  // It is possible to get a 4 kHz sample rate from the accelerometer by choosing 1 for  // accel_fchoice_b bit [3]; in this case the bandwidth is 1.13 kHz  uint8_t c = readByte(MPU9250_ADDRESS, ACCEL_CONFIG2); // get current ACCEL_CONFIG2 register value   6:	1dfc      	adds	r4, r7, #7   8:	2068      	movs	r0, #104	; 0x68   a:	211d      	movs	r1, #29   c:	f7ff fffe 	bl	0 <readByte>			c: R_ARM_THM_CALL	readByte  10:	1c03      	adds	r3, r0, #0  12:	7023      	strb	r3, [r4, #0]  c = c & ~0x0F; // Clear accel_fchoice_b (bit 3) and A_DLPFG (bits [2:0])    14:	1dfb      	adds	r3, r7, #7  16:	1dfa      	adds	r2, r7, #7  18:	7812      	ldrb	r2, [r2, #0]  1a:	210f      	movs	r1, #15  1c:	438a      	bics	r2, r1  1e:	701a      	strb	r2, [r3, #0]  c = c | 0x01;  // Set accelerometer rate to 1 kHz and bandwidth to 184 Hz  20:	1dfb      	adds	r3, r7, #7  22:	1dfa      	adds	r2, r7, #7  24:	7812      	ldrb	r2, [r2, #0]  26:	2101      	movs	r1, #1  28:	430a      	orrs	r2, r1  2a:	701a      	strb	r2, [r3, #0]  writeByte(MPU9250_ADDRESS, ACCEL_CONFIG2, c); // Write new ACCEL_CONFIG2 register value  2c:	1dfb      	adds	r3, r7, #7  2e:	781b      	ldrb	r3, [r3, #0]  30:	2068      	movs	r0, #104	; 0x68  32:	211d      	movs	r1, #29  34:	1c1a      	adds	r2, r3, #0  36:	f7ff fffe 	bl	0 <writeByte>			36: R_ARM_THM_CALL	writeByte  // Configure Interrupts and Bypass Enable  // Set interrupt pin active high, push-pull, hold interrupt pin level HIGH until interrupt cleared,  // clear on read of INT_STATUS, and enable I2C_BYPASS_EN so additional chips   // can join the I2C bus and all can be controlled by the Arduino as master    writeByte(MPU9250_ADDRESS, INT_PIN_CFG, 0x12);  // INT is 50 microsecond pulse and any read to clear    3a:	2068      	movs	r0, #104	; 0x68  3c:	2137      	movs	r1, #55	; 0x37  3e:	2212      	movs	r2, #18  40:	f7ff fffe 	bl	0 <writeByte>			40: R_ARM_THM_CALL	writeByte   writeByte(MPU9250_ADDRESS, INT_ENABLE, 0x41);   // Enable data ready (bit 0) and wake on motion (bit 6)  interrupt  44:	2068      	movs	r0, #104	; 0x68  46:	2138      	movs	r1, #56	; 0x38  48:	2241      	movs	r2, #65	; 0x41  4a:	f7ff fffe 	bl	0 <writeByte>			4a: R_ARM_THM_CALL	writeByte   // enable wake on motion detection logic (bit 7) and compare current sample to previous sample (bit 6)   writeByte(MPU9250_ADDRESS, MOT_DETECT_CTRL, 0xC0);    4e:	2068      	movs	r0, #104	; 0x68  50:	2169      	movs	r1, #105	; 0x69  52:	22c0      	movs	r2, #192	; 0xc0  54:	f7ff fffe 	bl	0 <writeByte>			54: R_ARM_THM_CALL	writeByte   // set accel threshold for wake up at  mG per LSB, 1 - 255 LSBs == 0 - 1020 mg), pic 0x19 for 25 mg   writeByte(MPU9250_ADDRESS, WOM_THR, 0x19);  58:	2068      	movs	r0, #104	; 0x68  5a:	211f      	movs	r1, #31  5c:	2219      	movs	r2, #25  5e:	f7ff fffe 	bl	0 <writeByte>			5e: R_ARM_THM_CALL	writeByte  // set sample rate in low power mode  /* choices are 0 == 0.24 Hz, 1 == 0.49 Hz, 2 == 0.98 Hz, 3 == 1.958 Hz, 4 == 3.91 Hz, 5 == 7.81 Hz   *             6 == 15.63 Hz, 7 == 31.25 Hz, 8 == 62.50 Hz, 9 = 125 Hz, 10 == 250 Hz, and 11 == 500 Hz   */  writeByte(MPU9250_ADDRESS, LP_ACCEL_ODR, 0x02);  62:	2068      	movs	r0, #104	; 0x68  64:	211e      	movs	r1, #30  66:	2202      	movs	r2, #2  68:	f7ff fffe 	bl	0 <writeByte>			68: R_ARM_THM_CALL	writeByte  c = readByte(MPU9250_ADDRESS, PWR_MGMT_1);  6c:	1dfc      	adds	r4, r7, #7  6e:	2068      	movs	r0, #104	; 0x68  70:	216b      	movs	r1, #107	; 0x6b  72:	f7ff fffe 	bl	0 <readByte>			72: R_ARM_THM_CALL	readByte  76:	1c03      	adds	r3, r0, #0  78:	7023      	strb	r3, [r4, #0]  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, c | 0x20);     // Write bit 5 to enable accel cycling  7a:	1dfb      	adds	r3, r7, #7  7c:	781b      	ldrb	r3, [r3, #0]  7e:	2220      	movs	r2, #32  80:	4313      	orrs	r3, r2  82:	b2db      	uxtb	r3, r3  84:	2068      	movs	r0, #104	; 0x68  86:	216b      	movs	r1, #107	; 0x6b  88:	1c1a      	adds	r2, r3, #0  8a:	f7ff fffe 	bl	0 <writeByte>			8a: R_ARM_THM_CALL	writeByte  gyromagSleep();  8e:	f7ff fffe 	bl	0 <accelWakeOnMotion>			8e: R_ARM_THM_CALL	gyromagSleep  delay(100); // Wait for all registers to reset   92:	2064      	movs	r0, #100	; 0x64  94:	f7ff fffe 	bl	0 <accelWakeOnMotion>			94: R_ARM_THM_CALL	delay}  98:	46bd      	mov	sp, r7  9a:	b003      	add	sp, #12  9c:	bd90      	pop	{r4, r7, pc}  9e:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.gyromagSleep:00000000 <gyromagSleep>:void gyromagSleep(){   0:	b590      	push	{r4, r7, lr}   2:	b083      	sub	sp, #12   4:	af00      	add	r7, sp, #0  uint8_t temp = 0;   6:	1dfb      	adds	r3, r7, #7   8:	2200      	movs	r2, #0   a:	701a      	strb	r2, [r3, #0]  temp = readByte(AK8963_ADDRESS, AK8963_CNTL);   c:	1dfc      	adds	r4, r7, #7   e:	200c      	movs	r0, #12  10:	210a      	movs	r1, #10  12:	f7ff fffe 	bl	0 <readByte>			12: R_ARM_THM_CALL	readByte  16:	1c03      	adds	r3, r0, #0  18:	7023      	strb	r3, [r4, #0]  writeByte(AK8963_ADDRESS, AK8963_CNTL, temp & ~(0x0F) ); // Clear bits 0 - 3 to power down magnetometer    1a:	1dfb      	adds	r3, r7, #7  1c:	781b      	ldrb	r3, [r3, #0]  1e:	220f      	movs	r2, #15  20:	4393      	bics	r3, r2  22:	b2db      	uxtb	r3, r3  24:	200c      	movs	r0, #12  26:	210a      	movs	r1, #10  28:	1c1a      	adds	r2, r3, #0  2a:	f7ff fffe 	bl	0 <writeByte>			2a: R_ARM_THM_CALL	writeByte  temp = readByte(MPU9250_ADDRESS, PWR_MGMT_1);  2e:	1dfc      	adds	r4, r7, #7  30:	2068      	movs	r0, #104	; 0x68  32:	216b      	movs	r1, #107	; 0x6b  34:	f7ff fffe 	bl	0 <readByte>			34: R_ARM_THM_CALL	readByte  38:	1c03      	adds	r3, r0, #0  3a:	7023      	strb	r3, [r4, #0]  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, temp | 0x10);     // Write bit 4 to enable gyro standby  3c:	1dfb      	adds	r3, r7, #7  3e:	781b      	ldrb	r3, [r3, #0]  40:	2210      	movs	r2, #16  42:	4313      	orrs	r3, r2  44:	b2db      	uxtb	r3, r3  46:	2068      	movs	r0, #104	; 0x68  48:	216b      	movs	r1, #107	; 0x6b  4a:	1c1a      	adds	r2, r3, #0  4c:	f7ff fffe 	bl	0 <writeByte>			4c: R_ARM_THM_CALL	writeByte  delay(10); // Wait for all registers to reset   50:	200a      	movs	r0, #10  52:	f7ff fffe 	bl	0 <gyromagSleep>			52: R_ARM_THM_CALL	delay}  56:	46bd      	mov	sp, r7  58:	b003      	add	sp, #12  5a:	bd90      	pop	{r4, r7, pc}Disassembly of section .text.gyromagWake:00000000 <gyromagWake>:void gyromagWake(uint8_t Mmode){   0:	b590      	push	{r4, r7, lr}   2:	b085      	sub	sp, #20   4:	af00      	add	r7, sp, #0   6:	1c02      	adds	r2, r0, #0   8:	1dfb      	adds	r3, r7, #7   a:	701a      	strb	r2, [r3, #0]  uint8_t temp = 0;   c:	1c3b      	adds	r3, r7, #0   e:	330f      	adds	r3, #15  10:	2200      	movs	r2, #0  12:	701a      	strb	r2, [r3, #0]  temp = readByte(AK8963_ADDRESS, AK8963_CNTL);  14:	1c3c      	adds	r4, r7, #0  16:	340f      	adds	r4, #15  18:	200c      	movs	r0, #12  1a:	210a      	movs	r1, #10  1c:	f7ff fffe 	bl	0 <readByte>			1c: R_ARM_THM_CALL	readByte  20:	1c03      	adds	r3, r0, #0  22:	7023      	strb	r3, [r4, #0]  writeByte(AK8963_ADDRESS, AK8963_CNTL, temp | Mmode ); // Reset normal mode for  magnetometer    24:	1c3a      	adds	r2, r7, #0  26:	320f      	adds	r2, #15  28:	1dfb      	adds	r3, r7, #7  2a:	7812      	ldrb	r2, [r2, #0]  2c:	781b      	ldrb	r3, [r3, #0]  2e:	4313      	orrs	r3, r2  30:	b2db      	uxtb	r3, r3  32:	200c      	movs	r0, #12  34:	210a      	movs	r1, #10  36:	1c1a      	adds	r2, r3, #0  38:	f7ff fffe 	bl	0 <writeByte>			38: R_ARM_THM_CALL	writeByte  temp = readByte(MPU9250_ADDRESS, PWR_MGMT_1);  3c:	1c3c      	adds	r4, r7, #0  3e:	340f      	adds	r4, #15  40:	2068      	movs	r0, #104	; 0x68  42:	216b      	movs	r1, #107	; 0x6b  44:	f7ff fffe 	bl	0 <readByte>			44: R_ARM_THM_CALL	readByte  48:	1c03      	adds	r3, r0, #0  4a:	7023      	strb	r3, [r4, #0]  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x01);   // return gyro and accel normal mode  4c:	2068      	movs	r0, #104	; 0x68  4e:	216b      	movs	r1, #107	; 0x6b  50:	2201      	movs	r2, #1  52:	f7ff fffe 	bl	0 <writeByte>			52: R_ARM_THM_CALL	writeByte  delay(10); // Wait for all registers to reset   56:	200a      	movs	r0, #10  58:	f7ff fffe 	bl	0 <gyromagWake>			58: R_ARM_THM_CALL	delay}  5c:	46bd      	mov	sp, r7  5e:	b005      	add	sp, #20  60:	bd90      	pop	{r4, r7, pc}  62:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.resetMPU9250:00000000 <resetMPU9250>:void resetMPU9250(){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0  // reset device  writeByte(MPU9250_ADDRESS, PWR_MGMT_1, 0x80); // Set bit 7 to reset MPU9250   4:	2068      	movs	r0, #104	; 0x68   6:	216b      	movs	r1, #107	; 0x6b   8:	2280      	movs	r2, #128	; 0x80   a:	f7ff fffe 	bl	0 <writeByte>			a: R_ARM_THM_CALL	writeByte  delay(100); // Wait for all registers to reset    e:	2064      	movs	r0, #100	; 0x64  10:	f7ff fffe 	bl	0 <resetMPU9250>			10: R_ARM_THM_CALL	delay}  14:	46bd      	mov	sp, r7  16:	bd80      	pop	{r7, pc}Disassembly of section .text.readMPU9250Data:00000000 <readMPU9250Data>://read ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, ACCEL_ZOUT_L, TEMP_OUT_H, TEMP_OUT_L, GYRO_XOUT_H, GYRO_XOUT_L, GYRO_YOUT_H, GYRO_YOUT_L, GYRO_ZOUT_H, GYRO_ZOUT_Lvoid readMPU9250Data(int16_t * destination){   0:	b580      	push	{r7, lr}   2:	b086      	sub	sp, #24   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]  uint8_t rawData[14];  // x/y/z accel register data stored here  readBytes(MPU9250_ADDRESS, ACCEL_XOUT_H, 14, &rawData[0]);  // Read the 14 raw data registers into data array   8:	1c3b      	adds	r3, r7, #0   a:	3308      	adds	r3, #8   c:	2068      	movs	r0, #104	; 0x68   e:	213b      	movs	r1, #59	; 0x3b  10:	220e      	movs	r2, #14  12:	f7ff fffe 	bl	0 <readBytes>			12: R_ARM_THM_CALL	readBytes  destination[0] = ((int16_t)rawData[0] << 8) | rawData[1] ;  // Turn the MSB and LSB into a signed 16-bit value  16:	1c3b      	adds	r3, r7, #0  18:	3308      	adds	r3, #8  1a:	781b      	ldrb	r3, [r3, #0]  1c:	021b      	lsls	r3, r3, #8  1e:	b29a      	uxth	r2, r3  20:	1c3b      	adds	r3, r7, #0  22:	3308      	adds	r3, #8  24:	785b      	ldrb	r3, [r3, #1]  26:	4313      	orrs	r3, r2  28:	b29a      	uxth	r2, r3  2a:	687b      	ldr	r3, [r7, #4]  2c:	801a      	strh	r2, [r3, #0]  destination[1] = ((int16_t)rawData[2] << 8) | rawData[3] ;    2e:	687b      	ldr	r3, [r7, #4]  30:	3302      	adds	r3, #2  32:	1c3a      	adds	r2, r7, #0  34:	3208      	adds	r2, #8  36:	7892      	ldrb	r2, [r2, #2]  38:	0212      	lsls	r2, r2, #8  3a:	b291      	uxth	r1, r2  3c:	1c3a      	adds	r2, r7, #0  3e:	3208      	adds	r2, #8  40:	78d2      	ldrb	r2, [r2, #3]  42:	430a      	orrs	r2, r1  44:	b292      	uxth	r2, r2  46:	801a      	strh	r2, [r3, #0]  destination[2] = ((int16_t)rawData[4] << 8) | rawData[5] ;   48:	687b      	ldr	r3, [r7, #4]  4a:	3304      	adds	r3, #4  4c:	1c3a      	adds	r2, r7, #0  4e:	3208      	adds	r2, #8  50:	7912      	ldrb	r2, [r2, #4]  52:	0212      	lsls	r2, r2, #8  54:	b291      	uxth	r1, r2  56:	1c3a      	adds	r2, r7, #0  58:	3208      	adds	r2, #8  5a:	7952      	ldrb	r2, [r2, #5]  5c:	430a      	orrs	r2, r1  5e:	b292      	uxth	r2, r2  60:	801a      	strh	r2, [r3, #0]  destination[3] = ((int16_t)rawData[6] << 8) | rawData[7] ;     62:	687b      	ldr	r3, [r7, #4]  64:	3306      	adds	r3, #6  66:	1c3a      	adds	r2, r7, #0  68:	3208      	adds	r2, #8  6a:	7992      	ldrb	r2, [r2, #6]  6c:	0212      	lsls	r2, r2, #8  6e:	b291      	uxth	r1, r2  70:	1c3a      	adds	r2, r7, #0  72:	3208      	adds	r2, #8  74:	79d2      	ldrb	r2, [r2, #7]  76:	430a      	orrs	r2, r1  78:	b292      	uxth	r2, r2  7a:	801a      	strh	r2, [r3, #0]  destination[4] = ((int16_t)rawData[8] << 8) | rawData[9] ;    7c:	687b      	ldr	r3, [r7, #4]  7e:	3308      	adds	r3, #8  80:	1c3a      	adds	r2, r7, #0  82:	3208      	adds	r2, #8  84:	7a12      	ldrb	r2, [r2, #8]  86:	0212      	lsls	r2, r2, #8  88:	b291      	uxth	r1, r2  8a:	1c3a      	adds	r2, r7, #0  8c:	3208      	adds	r2, #8  8e:	7a52      	ldrb	r2, [r2, #9]  90:	430a      	orrs	r2, r1  92:	b292      	uxth	r2, r2  94:	801a      	strh	r2, [r3, #0]  destination[5] = ((int16_t)rawData[10] << 8) | rawData[11] ;    96:	687b      	ldr	r3, [r7, #4]  98:	330a      	adds	r3, #10  9a:	1c3a      	adds	r2, r7, #0  9c:	3208      	adds	r2, #8  9e:	7a92      	ldrb	r2, [r2, #10]  a0:	0212      	lsls	r2, r2, #8  a2:	b291      	uxth	r1, r2  a4:	1c3a      	adds	r2, r7, #0  a6:	3208      	adds	r2, #8  a8:	7ad2      	ldrb	r2, [r2, #11]  aa:	430a      	orrs	r2, r1  ac:	b292      	uxth	r2, r2  ae:	801a      	strh	r2, [r3, #0]  destination[6] = ((int16_t)rawData[12] << 8) | rawData[13] ;   b0:	687b      	ldr	r3, [r7, #4]  b2:	330c      	adds	r3, #12  b4:	1c3a      	adds	r2, r7, #0  b6:	3208      	adds	r2, #8  b8:	7b12      	ldrb	r2, [r2, #12]  ba:	0212      	lsls	r2, r2, #8  bc:	b291      	uxth	r1, r2  be:	1c3a      	adds	r2, r7, #0  c0:	3208      	adds	r2, #8  c2:	7b52      	ldrb	r2, [r2, #13]  c4:	430a      	orrs	r2, r1  c6:	b292      	uxth	r2, r2  c8:	801a      	strh	r2, [r3, #0]}  ca:	46bd      	mov	sp, r7  cc:	b006      	add	sp, #24  ce:	bd80      	pop	{r7, pc}Disassembly of section .text.checkNewMagData:00000000 <checkNewMagData>:bool checkNewMagData(){   0:	b580      	push	{r7, lr}   2:	b082      	sub	sp, #8   4:	af00      	add	r7, sp, #0  bool test;  test = (readByte(AK8963_ADDRESS, AK8963_ST1) & 0x01);   6:	200c      	movs	r0, #12   8:	2102      	movs	r1, #2   a:	f7ff fffe 	bl	0 <readByte>			a: R_ARM_THM_CALL	readByte   e:	1c03      	adds	r3, r0, #0  10:	1c1a      	adds	r2, r3, #0  12:	2301      	movs	r3, #1  14:	4013      	ands	r3, r2  16:	607b      	str	r3, [r7, #4]  return test;  18:	687b      	ldr	r3, [r7, #4]}  1a:	1c18      	adds	r0, r3, #0  1c:	46bd      	mov	sp, r7  1e:	b002      	add	sp, #8  20:	bd80      	pop	{r7, pc}  22:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.checkNewAccelGyroData:00000000 <checkNewAccelGyroData>:bool checkNewAccelGyroData(){   0:	b580      	push	{r7, lr}   2:	b082      	sub	sp, #8   4:	af00      	add	r7, sp, #0  bool test;  test = (readByte(MPU9250_ADDRESS, INT_STATUS) & 0x01);   6:	2068      	movs	r0, #104	; 0x68   8:	213a      	movs	r1, #58	; 0x3a   a:	f7ff fffe 	bl	0 <readByte>			a: R_ARM_THM_CALL	readByte   e:	1c03      	adds	r3, r0, #0  10:	1c1a      	adds	r2, r3, #0  12:	2301      	movs	r3, #1  14:	4013      	ands	r3, r2  16:	607b      	str	r3, [r7, #4]  return test;  18:	687b      	ldr	r3, [r7, #4]}  1a:	1c18      	adds	r0, r3, #0  1c:	46bd      	mov	sp, r7  1e:	b002      	add	sp, #8  20:	bd80      	pop	{r7, pc}  22:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.checkWakeOnMotion:00000000 <checkWakeOnMotion>:bool checkWakeOnMotion(){   0:	b580      	push	{r7, lr}   2:	b082      	sub	sp, #8   4:	af00      	add	r7, sp, #0  bool test;  test = (readByte(MPU9250_ADDRESS, INT_STATUS) & 0x40);   6:	2068      	movs	r0, #104	; 0x68   8:	213a      	movs	r1, #58	; 0x3a   a:	f7ff fffe 	bl	0 <readByte>			a: R_ARM_THM_CALL	readByte   e:	1c03      	adds	r3, r0, #0  10:	1c1a      	adds	r2, r3, #0  12:	2340      	movs	r3, #64	; 0x40  14:	4013      	ands	r3, r2  16:	607b      	str	r3, [r7, #4]  return test;  18:	687b      	ldr	r3, [r7, #4]}  1a:	1c18      	adds	r0, r3, #0  1c:	46bd      	mov	sp, r7  1e:	b002      	add	sp, #8  20:	bd80      	pop	{r7, pc}  22:	46c0      	nop			; (mov r8, r8)Disassembly of section .text.initializeMPU9250Parameters:00000000 <initializeMPU9250Parameters>:void initializeMPU9250Parameters (){   0:	b580      	push	{r7, lr}   2:	b082      	sub	sp, #8   4:	af00      	add	r7, sp, #0	 // Specify sensor full scale	    mpu9250.Gscale = GFS_250DPS;   6:	4b07      	ldr	r3, [pc, #28]	; (24 <initializeMPU9250Parameters+0x24>)   8:	2200      	movs	r2, #0   a:	701a      	strb	r2, [r3, #0]	    mpu9250.Ascale= AFS_2G;   c:	4b05      	ldr	r3, [pc, #20]	; (24 <initializeMPU9250Parameters+0x24>)   e:	2200      	movs	r2, #0  10:	705a      	strb	r2, [r3, #1]	    // Choose either 14-bit or 16-bit magnetometer resolution	    uint8_t Mscale = MFS_16BITS;  12:	1dfb      	adds	r3, r7, #7  14:	2201      	movs	r2, #1  16:	701a      	strb	r2, [r3, #0]	    // 2 for 8 Hz, 6 for 100 Hz continuous magnetometer data read	    uint8_t Mmode= 0x02;  18:	1dbb      	adds	r3, r7, #6  1a:	2202      	movs	r2, #2  1c:	701a      	strb	r2, [r3, #0]}  1e:	46bd      	mov	sp, r7  20:	b002      	add	sp, #8  22:	bd80      	pop	{r7, pc}  24:	00000000 	.word	0x00000000			24: R_ARM_ABS32	mpu9250Disassembly of section .text.updateTime:00000000 <updateTime>:// Calculate the time the last update took for use in the quaternion filtersvoid updateTime(){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0  mpu9250.Now = PIT_CVAL1;   4:	4a0e      	ldr	r2, [pc, #56]	; (40 <updateTime+0x40>)   6:	238a      	movs	r3, #138	; 0x8a   8:	005b      	lsls	r3, r3, #1   a:	58d2      	ldr	r2, [r2, r3]   c:	4b0d      	ldr	r3, [pc, #52]	; (44 <updateTime+0x44>)   e:	635a      	str	r2, [r3, #52]	; 0x34    //Set integration time by time elapsed since last filter update  mpu9250.deltat = ((mpu9250.lastUpdate-mpu9250.Now) / 24000000.0f);  10:	4b0c      	ldr	r3, [pc, #48]	; (44 <updateTime+0x44>)  12:	6ada      	ldr	r2, [r3, #44]	; 0x2c  14:	4b0b      	ldr	r3, [pc, #44]	; (44 <updateTime+0x44>)  16:	6b5b      	ldr	r3, [r3, #52]	; 0x34  18:	1ad3      	subs	r3, r2, r3  1a:	1c18      	adds	r0, r3, #0  1c:	f7ff fffe 	bl	0 <__aeabi_ui2f>			1c: R_ARM_THM_CALL	__aeabi_ui2f  20:	1c03      	adds	r3, r0, #0  22:	1c18      	adds	r0, r3, #0  24:	4908      	ldr	r1, [pc, #32]	; (48 <updateTime+0x48>)  26:	f7ff fffe 	bl	0 <__aeabi_fdiv>			26: R_ARM_THM_CALL	__aeabi_fdiv  2a:	1c03      	adds	r3, r0, #0  2c:	1c1a      	adds	r2, r3, #0  2e:	4b05      	ldr	r3, [pc, #20]	; (44 <updateTime+0x44>)  30:	625a      	str	r2, [r3, #36]	; 0x24  mpu9250.lastUpdate = mpu9250.Now;  32:	4b04      	ldr	r3, [pc, #16]	; (44 <updateTime+0x44>)  34:	6b5a      	ldr	r2, [r3, #52]	; 0x34  36:	4b03      	ldr	r3, [pc, #12]	; (44 <updateTime+0x44>)  38:	62da      	str	r2, [r3, #44]	; 0x2c  //sum += deltat; // sum for averaging filter update rate  //sumCount++;}  3a:	46bd      	mov	sp, r7  3c:	bd80      	pop	{r7, pc}  3e:	46c0      	nop			; (mov r8, r8)  40:	40037000 	.word	0x40037000  44:	00000000 	.word	0x00000000			44: R_ARM_ABS32	mpu9250  48:	4bb71b00 	.word	0x4bb71b00Disassembly of section .text.delay:00000000 <delay>:void delay(int number){   0:	b580      	push	{r7, lr}   2:	b082      	sub	sp, #8   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]	delayFunc(number);   8:	687b      	ldr	r3, [r7, #4]   a:	1c18      	adds	r0, r3, #0   c:	f7ff fffe 	bl	0 <delayFunc>			c: R_ARM_THM_CALL	delayFunc}  10:	46bd      	mov	sp, r7  12:	b002      	add	sp, #8  14:	bd80      	pop	{r7, pc}  16:	46c0      	nop			; (mov r8, r8)